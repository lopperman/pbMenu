pbMenu As CanvasComponent:
    CollapsedMode():
        ThisProperty:
            Default: |-
                =If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal || Self.EnableCollapsedState<>true, false,     
                    With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                        If(IsBlank(collapseRec), 
                            pbMenu.VerticalDefaultCollapsed
                            , 
                            collapseRec.boolValue
                        )       
                    )
                )
    ConfirmAction(p_menuKey As String, p_itemKey As String, p_itemDisplay As String):
        p_menuKey:
            Default: ="Text"
        p_itemKey:
            Default: ="Text"
        p_itemDisplay:
            Default: ="Text"
        ThisProperty:
            Default: |+
                =With({Perf: {id: GUID(), start: Now(), action: $"CONFIRM ACTION: {p_menuKey}.{p_itemKey} ({p_itemDisplay})"}}, 
                    RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm");
                    Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: p_menuKey,itemKey: p_itemKey, action: "confirm", boolValue: true,  desc: p_itemDisplay});
                    If(pbMenu.PerformanceLogging=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    )
                )
                
    ConfirmMode():
        ThisProperty:
            Default: =spin.waiting<>true && CountIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")>0
    CreateInfoItem(p_menuKey As String, p_itemDisplay As String, p_itemAppearance As String, p_itemTooltip As String, p_addToCollection As Boolean):
        p_menuKey:
            Default: ="Text"
        p_itemDisplay:
            Default: ="Text"
        p_itemAppearance:
            Default: ="Text"
        p_itemTooltip:
            Default: ="Text"
        p_addToCollection:
            Default: =true
        ThisProperty:
            Default: |
                =With({newMenuItem: 
                    //get menu item structure
                    {
                        menuKey: Upper(TrimEnds(p_menuKey)), 
                        ItemKey: Upper($"_info_{GUID()}"), 
                        ItemDisplayName: TrimEnds(p_itemDisplay), 
                        ItemIconName: "Info", 
                        ItemAppearance: TrimEnds(p_itemAppearance), 
                        ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
                        ItemTooltip: TrimEnds(p_itemTooltip), 
                        ItemDisabled: false, 
                        disableOnSelect: false, 
                        confirmItemAction: false
                    }}
                    , 
                    If(p_addToCollection=true, 
                        RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                        Collect(col_pbMenu,newMenuItem)
                    );
                    newMenuItem 
                )
    CreateMenuItem(p_menuKey As String, p_ItemKey As String, p_ItemDisplayName As String, p_ItemIconName As String, p_ItemAppearance As String, p_ItemIconStyle As String, p_ItemTooltip As String, p_disableOnSelect As Boolean, p_confirmItemAction As Boolean, p_addToCollection As Boolean):
        p_menuKey:
            Default: ="Text"
        p_ItemKey:
            Default: ="Text"
        p_ItemDisplayName:
            Default: ="Text"
        p_ItemIconName:
            Default: ="Text"
        p_ItemAppearance:
            Default: =pbMenu.ItemAppearanceChoices.Primary
        p_ItemIconStyle:
            Default: =pbMenu.ItemIconStyleChoices.Filled
        p_ItemTooltip:
            Default: ="Text"
        p_disableOnSelect:
            Default: =false
        p_confirmItemAction:
            Default: =false
        p_addToCollection:
            Default: =false
        ThisProperty:
            Default: |
                =With({Perf: {id: GUID(), start: Now(), action: $"CREATE MENU ITEM: {p_menuKey}.{p_ItemKey} ({p_ItemDisplayName})"}}, 
                    With({isSpacer: (Len(TrimEnds(p_ItemKey))=0)=true},     
                        With({newMenuItem: 
                            If(isSpacer, 
                                //get spacer structure (without adding -- can be added to collection below if appropriate)
                                Self.CreateSpacer(p_menuKey,false), 
                                //get menu item structure
                                {menuKey: Upper(TrimEnds(p_menuKey)), ItemKey: Upper(TrimEnds(Coalesce(p_ItemKey,$"_spacer_{GUID()}"))), ItemDisplayName: If(isSpacer,"",TrimEnds(p_ItemDisplayName)), ItemIconName: If(isSpacer," ", TrimEnds(p_ItemIconName)), ItemAppearance: TrimEnds(p_ItemAppearance), ItemIconStyle: TrimEnds(p_ItemIconStyle), ItemTooltip: TrimEnds(p_ItemTooltip), ItemDisabled: isSpacer, disableOnSelect: p_disableOnSelect, confirmItemAction: p_confirmItemAction}
                            )}, 
                            If(p_addToCollection=true, 
                                RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                                Collect(col_pbMenu,newMenuItem)
                            );
                            If(pbMenu.PerformanceLogging=true, 
                                With({endTS: Now()}, 
                                    Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                                )
                            );
                            newMenuItem 
                        )
                    )
                )
    CreateSpacer(p_menuKey As String, p_addToCollection As Boolean):
        p_menuKey:
            Default: ="Text"
        p_addToCollection:
            Default: =true
        ThisProperty:
            Default: |
                =With({Perf: {id: GUID(), start: Now(), action: $"CREATE SPACER: {p_menuKey} (Add to collection: {p_addToCollection})"}}, 
                    With({newSpacer: 
                        If(Len(TrimEnds(p_menuKey))=0, 
                            Blank(), 
                            {
                                menuKey: Upper(TrimEnds(p_menuKey)), 
                                ItemKey: $"_spacer_{GUID()}", 
                                ItemDisplayName: " ", 
                                ItemIconName: "", 
                                ItemAppearance: Self.ItemAppearanceChoices.Transparent,  
                                ItemIconStyle: Self.ItemIconStyleChoices.Outline, 
                                ItemTooltip: "", 
                                ItemDisabled: true, 
                                disableOnSelect: false, 
                                confirmItemAction: false    
                            }
                        )}, 
                        If(p_addToCollection=true && Not(IsBlank(newSpacer)), 
                            Collect(col_pbMenu,newSpacer)
                        );
                        If(pbMenu.PerformanceLogging=true, 
                            With({endTS: Now()}, 
                                Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                            )
                        );
                        newSpacer
                    )
                )
    DoMenu(p_menuKey As String, p_itemKey As String):
        p_menuKey:
            Default: ="Text"
        p_itemKey:
            Default: ="Text"
        ThisProperty:
            Default: |-
                =With({mi: pbMenu.MenuItem(p_menuKey,p_itemKey)}, 
                    If(mi.confirmItemAction=true, 
                        If(Self.ConfirmMode() <> true, 
                            //Add 'confirm' action and waits for user to confirm or cancel
                            //cancel clears confirm action
                            //confirm calls DoMenu again, which can then move forward
                            Self.ConfirmAction(p_menuKey,p_itemKey,mi.ItemDisplayName)
                            , 
                            //clear the 'confirm' action, which is now confirmed, and 
                            //process menuItem as normal
                            RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")
                        )
                    );
                    If(Self.ConfirmMode() <> true, 
                        If(pbMenu.ManageItemStates = true, 
                            If(CountIf(pbMenu.CurrentMenuItems,ItemDisabled=true)>0, 
                                pbMenu.ItemState_UpdateAll(true)
                            );
                            If(mi.disableOnSelect=true, 
                                pbMenu.ItemState(mi.ItemKey,false)
                            )
                        );
                        //Raise 'OnBeforeAction'.  If handled in event on screen ('true' returned), no further action is taken.
                        //If not handled in the 'OnBeforeAction', will attempt to handle below and show error if was not handled.
                        If(Self.OnBeforeAction(p_itemKey) = true, 
                            true
                            , 
                            With({handledHere: 
                                Switch(Upper(p_itemKey), 
                                    "LAUNCHGITHUB", Launch("https://github.com/lopperman"); true, 
                                    "LAUNCHREDDIT", Launch("https://www.reddit.com/user/ITFuture"); true, 
                                    "GOOGLE", Launch("https://www.google.com"); true, 
                                    "MINAVPERF", Navigate(PerformanceLog,ScreenTransition.Fade); true, 
                
                                    //not handled
                                    Notify("NO ACTION WAS TAKEN FOR MENU ITEM: " & p_menuKey & "." & p_itemKey & " (" & mi.ItemDisplayName & ")",NotificationType.Error,5000);
                                    false
                                )}, 
                                handledHere
                            )
                        );
                    )
                )
    Information():
        ThisProperty:
            Default: |-
                =[
                    {
                        name: "About", 
                        type: "General pbMenu Help",
                        desc: "** NOTE: '[pbMenu]' is referenced in this documentation in relation to getting/setting/calling actions for a pbMenu component. Please remember that 'pbMenu' can never be referenced directly from a screen, and should be replaced with the name of the pbMenu component on your screen.  For example, if you added a pbMenu component to your screen, and named it 'mainMenu1', that all interactions for that menu would use 'mainMenu1', and not 'pbMenu'"        
                    },
                    {
                        name: "ToolbarOrientation", 
                        valText: Self.ToolbarOrientation, 
                        dataType: "Text", 
                        externalUse: "[pbMenu].LayoutChoices.Horizontal (default), or [pbMenu].LayoutChoices.Vertical", 
                        type: "Input Property",
                        desc: "Use to get or set the orientation of [pbMenu]"
                    },
                    {
                        name: "CurrentMenuItems", 
                        valTable: Self.CurrentMenuItems, 
                        dataType: "Table", 
                        externalUse: "Reference Only", 
                        type: "Output Property",
                        desc: "Current Menu Items.   Retrieved by filtering items from 'MenuData' datasource, where menuName=[pbMenu].MenuKey"
                    },
                    {
                        name: "CancelMenuColorPalette", 
                        valColor: Self.CancelMenuColorPalette, 
                        dataType: "Color", 
                        externalUse: "Use to set color palette of Confirmation 'Cancel' button; Default is RGBA(0,0,0,0)", 
                        type: "Input Property",
                        desc: "Color Palette used when displaying 'Cancel' button for required user confirmation"
                    },
                    {
                        name: "CollapseMode()", 
                        valBoolean: Self.CollapsedMode(), 
                        dataType: "Boolean", 
                        externalUse: "Reference Only (must be called as function)", 
                        type: "Output Function",
                        desc: "Returns true when 'ToolbarOrientation' is Vertical and menu is collapsed and only displaying icons"
                    },
                    {
                        name: "EnableCollapsedState", 
                        valBoolean: Self.EnableCollapsedState, 
                        dataType: "Boolean", 
                        externalUse: "Set to 'false' to prevent vertical menu from ever displaying in collapsed/icon-only mode", 
                        type: "Input Property", 
                        desc: "Defaults to true; controls whether vertical menu can be collapsed"
                    }, 
                    {
                        name: "ConfirmationColorPalette", 
                        valColor: Self.ConfirmationColorPalette, 
                        dataType: "Color", 
                        externalUse: "Use to set color palette of Confirmation 'Confirm' button; Default is 'PowerAppsTheme.Colors.Primary'", 
                        type: "Input Property",
                        desc: "Color Palette used when displaying 'Confirm' button for required user confirmation"
                    }, 
                    {
                        name: "ConfirmMode", 
                        valBoolean: Self.ConfirmMode(), 
                        dataType: "Boolean", 
                        externalUse: "Reference Only, must call as function", 
                        type: "Output Function", 
                        desc: "When user has selected a menu item which requires confirmation, [pbMenu].'ConfirmMode()' will return true until user has selected 'Confirm' or 'Cancel'"
                    }, 
                    {   
                        name: "ControlGUID", 
                        valText: Self.ControlGUID, 
                        dataType: "Text", 
                        externalUse: "Reference Only.  VALUE WILL CHANGE BETWEEN SESSIONS!", 
                        type: "Output Property", 
                        desc: "Unique value which can be used at runtime only, and may update each time a screen becomes visible.  The purpose of this property is to manage specific state information when multiple pbMenu components exist on the same screen"
                    }, 
                    {
                        name: "ItemAppearanceChoices", 
                        valRecord: Self.ItemAppearanceChoices, 
                        dataType: "Record", 
                        externalUse: "Use to set 'ItemAppearance' property when creating new menu items", 
                        type: "Output Property", 
                        desc: "Helper property wich can be used when setting value for 'ItemAppearance', when creating a new menu item using [pbMenu].'Create Menu Item'()"
                    }, 
                    {
                        name: "ItemIconStyleChoices", 
                        valRecord: Self.ItemIconStyleChoices, 
                        dataType: "Record", 
                        externalUse: "Use to set 'ItemIconStyle' property when creating new menu items", 
                        type: "Output Property", 
                        desc: "Helper property which can be used when setting value for 'ItemIconStyle', when creating a new menu item using [pbMenu].'Create Menu Item'"
                    }, 
                    {
                        name: "LayoutChoices", 
                        valRecord: Self.LayoutChoices, 
                        dataType: "Record", 
                        externalUse: "Helper used to set valid [pbMenu].ToolbarOrientation", 
                        type: "Output Property", 
                        desc: "Helper property which can be used when setting value of [pbMenu].ToolbarOrientation"
                    }, 
                    {
                        name: "ConfirmAction", 
                        dataType: "n/a", 
                        externalUse: "Optionally can be used to trigger a menu item selection confirmation (see desc)", 
                        type: "Component Action", 
                        desc: "Trigger action which requires user to confirm or cancel selected menu item.  Used internally by pbMenu when a menu item is selected that was created with 'confirmItemAction' = true. While not intended to be called externally, this action can be triggered outside the pbMenu component as long as the parameter arguments (p_menuKey, p_itemKey, p_itemDisplay) match a menu item which currently is being displayed in [pbMenu]"
                    }, 
                    {
                        name: "CreateMenuItem", 
                        type: "Component Action", 
                        dataType: "Record", 
                        externalUse: "Returns Menu Item Record data which is also automatically added to collection: col_pbMenu if the 'p_addToCollection' argument is true", 
                        desc: "Returns a menu item record based on provided parameter values.  By default, new menu item is not added to a data source and therefore will not be available for use.  When called with p_addToCollection=true, the new menu item will be added to col_pbMenu (default data source for [pbMenu]), and becomes available for use by the pbMenu component.  See 'MenuData' for more information.", 
                        example: $"To get the correct structure (record) of a menu item you wish to add, which will be stored in an external datasource -- like SharePoint or DataVerse -- the following would return that record and NOT add it to the default MenuData datasource ('col_pbMenu'):  [pbMenu].CreateMenuItem({Char(34)}Main{Char(34)},{Char(34)}miNavBuild{Char(34)},{Char(34)}MENU BUILDER{Char(34)},{Char(34)}ArrowRight{Char(34)},[pbMenu].ItemAppearanceChoices.Primary,[pbMenu].ItemIconStyleChoices.Filled,{Char(34)}Build a Menu{Char(34)},false,false,false);, setting the last parameter to 'true' would cause the new menu item to also be added to 'col_pbMenu'"
                    }, 
                    {
                        name: "DoMenu", 
                        dataType: "n/a", 
                        externalUse: "Optionally usee to trigger a menu item selection (see desc)", 
                        type: "Component Action", 
                        desc: "Called when user selects a menu item which was rendered from [pbMenu].MenuData data source. Can also be called externally. When a menu item that requires user confirmation is selected, 'DoMenu' is not called until user also selects the confirmation button. When 'DoMenu' is called externally, the item key property is NOT required to correlate to a menu item currently available, as long as the pbMenu being called is able to process the 'p_ItemKey' argument in the [pbMenu].OnBeforeAction event on the current screen."
                    }, 
                    {
                        name: "ManageItemStates", 
                        valBoolean: Self.ManageItemStates, 
                        dataType: "Boolean", 
                        externalUse: "Used to enable a pbMenu to change menu item states automatically (default: true)", 
                        type: "Input Property", 
                        desc: "When set to true (default), any menu item selected which has 'disableOnSelect' property set to true, will become disabled when selected, and will become re-enabled when any other menu item is selected. When 'ManageItemStates' is set to false, the 'disableOnSelect' menu item property is ignored"
                    }, 
                    {
                        name: "ItemState", 
                        dataType: "n/a", 
                        externalUse: "can be used to manually enable/disable menu items (when [pbMenu].ManageItemStates is false)", 
                        type: "Component Action", 
                        desc: "Used internally by pbMenu to enable/disable a menu item.  Can be called externally to enable/disable a menu item at any time.  Note:  When 'ManageItemStates' is set to true, pbMenu will allways re-enable all menu items when any menu item is selected."
                    }, 
                    {
                        name: "ItemState_UpdateAll", 
                        type: "Component Action", 
                        desc: "Used internally to re-enable all menu items.  Can be called externally to enable or disable all menu items", 
                        canCall: true 
                    }, 
                    {
                        name: "MenuColorPalette", 
                        valColor: Self.MenuColorPalette, 
                        type: "Color, Input Property", 
                        desc: "Color pallete used for menu items.  Defaults to 'PowerAppsTheme.Colors.Primary'", 
                        canSet: true 
                    }, 
                    {
                        name: "MenuData_All", 
                        valTable: Self.MenuData_All, 
                        type: "Table, Output Property", 
                        desc: "Unfiltered records from col_pbMenu. This Table/collection contains configuration records for all menu items in all defined menus"
                    }, 
                    {
                        name: "IsBusy", 
                        valBoolean: Self.IsBusy, 
                        type: "Boolean, Input Property", 
                        desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                    }, 
                    {
                        name: "BusyMessage", 
                        valText: Self.BusyMessage, 
                        type: "Text, Input Property", 
                        desc: "The message that is displayed in the pbMenu container, when pbMenu.IsBusy=true, and pbMenu.BusyBehavior='Spinner'."
                    }, 
                    {
                        name: "BusyBehavior", 
                        valText: Self.BusyBehavior, 
                        type: "Text, Input Property", 
                        desc: "Text value to indicate pbMenu behavior when pbMenu.IsBusy=true.  A helper property (pbMenu.BusyBehaviorChoices) can be use to set this property.  Valid value are either 'BusyBehaviorChoices.Spinning' ('Spinning'), or 'BusyBehaviorChoices.Disabled' ('Disabled').  When this property is missing or contains an invalid value, the default value ('Spinning') will be used."
                    }, 
                    {
                        name: "BusyBehaviorChoices", 
                        valRecord: Self.BusyBehaviorChoices, 
                        type: "Record, Output Property", 
                        desc: "Helper property which contains valid choices for the pbMenu.BusyBehavior input property"
                    }, 
                    {
                        name: "ToolbarPadding", 
                        valText: Self.ToolbarPadding, 
                        type: "Text, Input Property (with default)", 
                        desc: "Toolbar padding is managed automatically ('Medium' for Horizontal Layout, 'Small' for Vertical Layout.)  If adjustment is necessary, can be overridden ('Small', 'Medium', 'Large').  A helper property exists to select choices (ToolbarPaddingChoices).  For example, if the name of your on-screen pbMenu component was 'myMenu' and you wanted to force 'Large' padding, you would set the 'ToolbarPadding' property to: myMenu.ToolbarPaddingChoices.Large"
                    }, 
                    {
                        name: "ToolbarPaddingChoices", 
                        valRecord: Self.ToolbarPaddingChoices, 
                        type: "Record, Output Property", 
                        desc: "Helper property which provides valid 'ToolbarPadding' choices"
                    }
                
                ]
    ItemState(p_itemKey As String, p_enabled As Boolean, p_enablePerfLog As Boolean):
        p_itemKey:
            Default: ="Text"
        p_enabled:
            Default: =true
        p_enablePerfLog:
            Default: =true
        ThisProperty:
            Default: |
                =With({Perf: {id: GUID(), start: Now(), action: $"ITEM STATE CHANGE: {pbMenu.MenuKey}.{p_itemKey} (enabled: {p_enabled})"}}, 
                    If(Not(StartsWith(Lower(p_itemKey),"_spacer_")) || Not(p_enabled), 
                        UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey) && Upper(ItemKey)=Upper(p_itemKey),{ItemDisabled:Not(p_enabled)})        
                    );
                
                //    RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="disable" && Upper(itemKey)=Upper(p_itemKey));
                //    With({isSpacer:StartsWith(Lower(p_itemKey),"_spacer_")}, 
                //        With({tmpMenuItem: pbMenu.MenuItem(pbMenu.MenuKey,p_itemKey), shouldDisable: If(isSpacer, true, Not(p_enabled))}, 
                //            If(p_enabled=false, 
                //                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: p_itemKey, action: "disable", boolValue: true,  desc: ""});
                //            );
                //            If(tmpMenuItem.ItemDisabled<>shouldDisable, 
                //                Patch(col_pbMenu,tmpMenuItem,{ItemDisabled:shouldDisable})
                //            )
                //        )
                //    );
                    If(pbMenu.PerformanceLogging=true && p_enablePerfLog=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    )
                )
    ItemState_UpdateAll(p_Enabled As Boolean):
        p_Enabled:
            Default: =true
        ThisProperty:
            Default: |
                =With({Perf: {id: GUID(), start: Now(), action: $"UPDATE ITEM STATES (ALL): {pbMenu.MenuKey} (Enabled: {p_Enabled})"}}, 
                    UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey),{ItemDisabled:Not(p_Enabled)});
                
                //    ForAll(pbMenu.MenuItems As mItem, 
                //        pbMenu.ItemState(mItem.ItemKey,p_Enabled,false)
                //    );
                
                //    pbMenu.Reset();
                //    If(pbMenu.PerformanceLogging=true, 
                //        With({endTS: Now()}, 
                //            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                //        )
                //    )
                )
    MenuItem(p_menuKey As String, p_itemKey As String):
        p_menuKey:
            Default: ="Text"
        p_itemKey:
            Default: ="Text"
        ThisProperty:
            Default: =LookUp(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_itemKey))
    MinimumHeight():
        ThisProperty:
            Default: =If(Upper(Self.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Horizontal),If(Self.OverrideMinHeight>0,Self.OverrideMinHeight, 50),140) 
    MinimumWidth():
        ThisProperty:
            Default: |
                =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal,200,
                    If(pbMenu.CollapsedMode()=true,50,
                        If(pbMenu.OverrideExpandedWidth<=0,
                            120, 
                            pbMenu.OverrideExpandedWidth
                        )
                    )
                )
    OnBeforeAction(p_itemKey As String):
        p_itemKey:
            Default: ="Text"
        ThisProperty:
            Default: |-
                =Switch(Upper(p_itemKey), 
                    //Add each menu item key here that you wish to handle from a specific pbMenu component added to a screen
                    //For menu items that will be rendered on multiple pbMenu components in your app, you can optionall ** not **
                    "[itemKey]",
                        //some work;
                        //some more work;
                        //return 'true
                        true, 
                
                    //always return false for unhandled menu item selections, so control can be passed back to [pbMenu].DoMenu()
                    false
                )
    OnRemoveMenuItem(p_menuKey As String, p_menuItemKey As String):
        p_menuKey:
            Default: ="Text"
        p_menuItemKey:
            Default: ="Text"
        ThisProperty:
            Default: =
    RemoveMenuItem(p_menuKey As String, p_menuItemKey As String):
        p_menuKey:
            Default: ="Text"
        p_menuItemKey:
            Default: ="Text"
        ThisProperty:
            Default: |-
                =RemoveIf(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_menuItemKey));
                Self.OnRemoveMenuItem(p_menuKey,p_menuItemKey)
    Reset():
        ThisProperty:
            Default: =Reset(pbMenu)
    BorderColor: =PowerAppsTheme.Colors.Darker20
    BorderWidth: =1
    BusyBehavior: =Self.BusyBehaviorChoices.Spinning
    BusyBehaviorChoices: |-
        ={Spinning: "Spinning", Disabled: "Disabled"}
    BusyMessage: =spin.msg
    CancelMenuColorPalette: =RGBA(0, 0, 0, 1)
    ConfirmationColorPalette: =RGBA(0, 0, 0, 1)
    ControlGUID: =GUID()
    CurrentMenuItems: |-
        =With({fItems: Filter(col_pbMenu,Upper(menuKey)=Upper(pbMenu.MenuKey))}, 
            If(CountRows(fItems)=0, 
                [
                    pbMenu.MissingMenuRecord
                ]
                , 
                ShowColumns(fItems,ItemKey,ItemDisplayName,ItemIconName, ItemAppearance, ItemIconStyle, ItemTooltip, ItemDisabled)
            )
        )
    EnableCollapsedState: =true
    Fill: =RGBA(0, 0, 0, 0)
    Height: =140
    IsBusy: =spin.waiting=true 
    ItemAppearanceChoices: |-
        ={Primary: "Primary", Secondary: "Secondary", Outline: "Outline", Subtle: "Subtle", Transparent: "Transparent"}
    ItemIconStyleChoices: |-
        ={Outline: "Outline", Filled: "Filled"}
    LayoutChoices: |-
        ={Horizontal: "Horizontal", Vertical: "Vertical"}
    ManageItemStates: =true
    MenuColorPalette: =PowerAppsTheme.Colors.Primary
    MenuData_All: =col_pbMenu
    MenuItemTextColor: =
    MenuKey: ="Main"
    MissingMenuRecord: |-
        ={            
            ItemKey: Upper("_MISSING"), 
            ItemDisplayName:  "'" & pbMenu.MenuKey & "' menu items not found!", 
            ItemIconName: "ErrorCircle", 
            ItemAppearance: pbMenu.ItemAppearanceChoices.Primary, 
            ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
            ItemTooltip: "No Menu Items Found", 
            ItemDisabled: false
        }
    OnReset: =
    OverrideExpandedWidth: =0
    OverrideMinHeight: =0
    PerformanceLogging: =false
    ShowNavBackButton: =false
    StaticBackMenuItem: |-
        ={            
            ItemKey: Upper("_BACK"), 
            ItemDisplayName:  "BACK", 
            ItemIconName: "ArrowLeft", 
            ItemAppearance: pbMenu.ItemAppearanceChoices.Outline, 
            ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
            ItemTooltip: "Go to last screen", 
            ItemDisabled: false, 
            confirmItemAction: false, 
            disableOnSelect: false 
        }
    StaticCollapseMenuRecord: |-
        ={            
            ItemKey: Upper("_COLLAPSE"), 
            ItemDisplayName:  "", 
            ItemIconName: If(pbMenu.CollapsedMode()=true,"ChevronRight","ChevronLeft"), 
            ItemAppearance: pbMenu.ItemAppearanceChoices.Outline, 
            ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
            ItemTooltip: If(pbMenu.CollapsedMode()=true,"Expand Menu","Collapse Menu"), 
            ItemDisabled: false, 
            confirmItemAction: false, 
            disableOnSelect: false 
        }
    ToolbarOrientation: =pbMenu.LayoutChoices.Horizontal
    ToolbarPadding: =""
    ToolbarPaddingChoices: |-
        ={Default: "Default", Small: 'Toolbar.Padding'.Small,Medium: 'Toolbar.Padding'.Medium,Large: 'Toolbar.Padding'.Large}
    VerticalDefaultCollapsed: =true
    Width: =640
    X: =0
    Y: =0
    ZIndex: =1

    contConfirm As groupContainer.manualLayoutContainer:
        BorderColor: =pbMenu.BorderColor
        BorderThickness: =Min(pbMenu.BorderWidth,3)
        DropShadow: =DropShadow.Light
        Height: =If(contMenu.Height > 100,100,tbMain.Height)
        RadiusBottomLeft: =4
        RadiusBottomRight: =4
        RadiusTopLeft: =4
        RadiusTopRight: =4
        Visible: =(pbMenu.IsBusy=false || pbMenu.BusyBehavior=pbMenu.BusyBehaviorChoices.Disabled) && pbMenu.ConfirmMode()=true
        Width: =If(tbMain.Width <= 500,tbMain.Width, Min(tbMain.Width,App.ActiveScreen.Width * .50))
        X: =2
        Y: =2
        ZIndex: =1

        btnConfirmMenu As Button:
            Appearance: ='ButtonCanvas.Appearance'.Primary
            BasePaletteColor: =pbMenu.ConfirmationColorPalette
            DisplayMode: =If(pbMenu.IsBusy,DisplayMode.Disabled, DisplayMode.Edit)
            FontWeight: =FontWeight.Bold
            Height: =If(Upper(pbMenu.ToolbarOrientation)=Upper("Vertical"),Parent.Height * .6, Parent.Height) - Self.Y * 2 
            Icon: ="CheckmarkCircle"
            IconStyle: ='ButtonCanvas.IconStyle'.Filled
            Layout: =If(Upper(pbMenu.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Vertical) && pbMenu.CollapsedMode()=true,'ButtonCanvas.Layout'.TextOnly,'ButtonCanvas.Layout'.IconBefore)
            OnSelect: |-
                =With({confAction: LookUp(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")}, 
                    If(Not(IsBlank(confAction)), 
                        pbMenu.DoMenu(confAction.menuKey,confAction.itemKey)         
                    )
                )
            Text: |-
                =If(Upper(pbMenu.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Vertical) && pbMenu.CollapsedMode()=true,"CON-FIRM",
                IfError("CONFIRM: " & LookUp(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm").desc ,"n/a"))
            Width: =If(Upper(pbMenu.ToolbarOrientation)=Upper("Vertical"),Parent.Width, Parent.Width * .6 - Self.X * 2) - Parent.BorderThickness * 2 
            X: =2
            Y: =2
            ZIndex: =1

        btnCancelMenu As Button:
            Align: =If(Upper(pbMenu.ToolbarOrientation)=Upper("Vertical"),Align.Center,Align.Left)
            Appearance: ='ButtonCanvas.Appearance'.Transparent
            BasePaletteColor: = pbMenu.CancelMenuColorPalette
            DisplayMode: =If(pbMenu.IsBusy,DisplayMode.Disabled, DisplayMode.Edit)
            FontWeight: =FontWeight.Bold
            Height: =If(Upper(pbMenu.ToolbarOrientation)=Upper("Vertical"),Parent.Height - Self.Y - 2, Parent.Height)
            Icon: ="DismissCircle"
            IconStyle: ='ButtonCanvas.IconStyle'.Filled
            Layout: =If(Upper(pbMenu.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Vertical) && pbMenu.CollapsedMode()=true,'ButtonCanvas.Layout'.TextOnly,'ButtonCanvas.Layout'.IconBefore)
            OnSelect: =RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm");
            Text: |
                =If(Upper(pbMenu.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Vertical) && pbMenu.CollapsedMode()=true,"can-cel","CANCEL")
            Width: =If(Upper(pbMenu.ToolbarOrientation)=Upper("Vertical"),Parent.Width - Parent.BorderThickness * 2, Parent.Width - Self.X - Parent.BorderThickness * 2 )
            X: =If(Upper(pbMenu.ToolbarOrientation)=Upper("Vertical"),2,Parent.Width * .6)
            Y: =If(Upper(pbMenu.ToolbarOrientation)=Upper("Vertical"),Parent.Height * .6,2) 
            ZIndex: =2

    contMenu As groupContainer.manualLayoutContainer:
        BorderColor: =pbMenu.BorderColor
        BorderThickness: =Min(pbMenu.BorderWidth,3)
        DropShadow: =DropShadow.Light
        Height: =pbMenu.Height - Self.Y -2
        RadiusBottomLeft: =4
        RadiusBottomRight: =4
        RadiusTopLeft: =4
        RadiusTopRight: =4
        Visible: =(pbMenu.IsBusy=false || pbMenu.BusyBehavior=pbMenu.BusyBehaviorChoices.Disabled) && pbMenu.ConfirmMode()<>true
        Width: =pbMenu.Width - Self.X -2
        X: =2
        Y: =2
        ZIndex: =2

        tbMain As Toolbar.pcfdataset:
            Alignment: =pbMenu.ToolbarOrientation
            BasePaletteColor: =If(CountIf(pbMenu.CurrentMenuItems,true)=0, Color.Red, pbMenu.MenuColorPalette)
            DisplayMode: =If(pbMenu.IsBusy,DisplayMode.Disabled, DisplayMode.Edit)
            FontColor: =pbMenu.MenuItemTextColor
            Height: =contMenu.Height
            Items: |-
                =If(Upper(pbMenu.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Vertical), 
                    If(pbMenu.ShowNavBackButton,     
                        If(pbMenu.EnableCollapsedState, 
                            Table(pbMenu.StaticCollapseMenuRecord, pbMenu.StaticBackMenuItem,pbMenu.CurrentMenuItems), 
                            Table(pbMenu.StaticBackMenuItem,pbMenu.CurrentMenuItems)
                        ), 
                        If(pbMenu.EnableCollapsedState, 
                            Table(pbMenu.StaticCollapseMenuRecord, pbMenu.CurrentMenuItems), 
                            Table(pbMenu.CurrentMenuItems)
                        )
                    )
                    ,
                    If(pbMenu.ShowNavBackButton, 
                        Table(pbMenu.StaticBackMenuItem,pbMenu.CurrentMenuItems), 
                        pbMenu.CurrentMenuItems
                    )
                )
            Layout: |-
                =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal || pbMenu.CollapsedMode()<>true,
                    'Toolbar.Layout'.IconBefore
                    , 
                    'Toolbar.Layout'.IconOnly 
                )
            OnSelect: |+
                =With({Perf: {id: GUID(), start: Now(), action: $"MENU ITEM SELECT: {pbMenu.MenuKey}.{Self.Selected.ItemKey} ({Self.Selected.ItemDisplayName})"}}, 
                    With({menuItemKey: Self.Selected.ItemKey}, 
                        Switch(Upper(menuItemKey),  
                            "_COLLAPSE", 
                                If(CountIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID))=0, 
                                    Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: pbMenu.VerticalDefaultCollapsed,  desc: ""});
                                );
                                With({collapseRec: LookUp(col_pbMenuUtil, menuGuid=GUID(pbMenu.ControlGUID) && action="collapse")}, 
                                    If(collapseRec.boolValue = pbMenu.CollapsedMode(), 
                                        Patch(col_pbMenuUtil, collapseRec, {boolValue:Not(collapseRec.boolValue)})
                                    )
                                ),
                            "_BACK", 
                                If(pbMenu.ManageItemStates=true, pbMenu.ItemState_UpdateAll(true));
                                Back()
                            , 
                            With({noOp: StartsWith(Upper(menuItemKey),"_SPACER_") || StartsWith(Upper(menuItemKey),"_INFO_")}, 
                                If(noOp=false, 
                                    With({doMenuResponse: pbMenu.DoMenu(pbMenu.MenuKey, menuItemKey)}, 
                                        If(IsError(doMenuResponse), 
                                            Notify($"An Error Occured Processing Menu Item {pbMenu.MenuKey}.{menuItemKey}",NotificationType.Error,5000), 
                                            If(doMenuResponse=false, 
                                                Notify($"Menu Item {pbMenu.MenuKey}.{menuItemKey} was not handled.",NotificationType.Error,5000)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    );
                    If(pbMenu.PerformanceLogging=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: Value(DateDiff(Perf.start,endTS,TimeUnit.Milliseconds)), startVal: Value(TimeValue(Perf.start)), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    )
                )
                
            Padding: =If(IsBlank(pbMenu.ToolbarPadding) || Upper(pbMenu.ToolbarPadding)="DEFAULT",If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal,'Toolbar.Padding'.Medium,'Toolbar.Padding'.Small),pbMenu.ToolbarPadding)
            Visible: =pbMenu.Height >= pbMenu.MinimumHeight()
            Width: =contMenu.Width
            X: =0
            Y: =0
            ZIndex: =1

        lblHeightWarning As Text:
            DisplayMode: =DisplayMode.Edit
            Fill: =RGBA(255, 255, 0, 1)
            FontColor: =RGBA(215, 58, 60, 1)
            Height: =contMenu.Height
            Size: =10
            Text: |-
                ="pbMenu control size (H:" & pbMenu.Height & ", W:" & pbMenu.Width &  ") is less than minimum required size (MinHeight: " & pbMenu.MinimumHeight() & ", MinWidth: " & pbMenu.MinimumWidth() & ")"
            Visible: =pbMenu.Height < pbMenu.MinimumHeight() || pbMenu.Width < pbMenu.MinimumWidth()
            Width: =contMenu.Width
            X: =0
            Y: =0
            ZIndex: =2

    contSpinner As groupContainer.manualLayoutContainer:
        BorderColor: =pbMenu.BorderColor
        BorderThickness: =pbMenu.BorderWidth
        DropShadow: =DropShadow.Light
        Height: =Parent.Height - Self.Y * 2 
        RadiusBottomLeft: =4
        RadiusBottomRight: =4
        RadiusTopLeft: =4
        RadiusTopRight: =4
        Visible: =pbMenu.IsBusy && pbMenu.BusyBehavior <> pbMenu.BusyBehaviorChoices.Disabled
        Width: =Parent.Width - Self.X * 2 
        X: =2
        Y: =2
        ZIndex: =3

        Spinner1 As Spinner:
            DisplayMode: =DisplayMode.Edit
            FontWeight: =FontWeight.Bold
            Height: =Parent.Height - Self.Y * 2 -8
            Label: =If(pbMenu.ToolbarOrientation="Horizontal" || pbMenu.CollapsedMode()=false, Coalesce(pbMenu.BusyMessage,"Please wait ..."),"wait")
            LabelPosition: =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal, 'Spinner.LabelPosition'.After,'Spinner.LabelPosition'.Below)
            SpinnerSize: =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Vertical,If(pbMenu.CollapsedMode()=true,'Spinner.SpinnerSize'.ExtraSmall, 'Spinner.SpinnerSize'.Small), 'Spinner.SpinnerSize'.Medium)
            Width: =Parent.Width - Self.X * 2 
            X: =2
            Y: =2
            ZIndex: =1

        "progress_pbMenu As 'Progress Bar'":
            DisplayMode: =DisplayMode.Edit
            Height: =8
            Indeterminate: =true
            ProgressColor: ='Progress.ProgressColor'.Brand
            Shape: ='Progress.Shape'.Rounded
            Thickness: ='Progress.Thickness'.Large
            Width: =Parent.Width
            X: =0
            Y: =Parent.Height - Self.Height - 4
            ZIndex: =2

