"'pbMenu Demo' As screen":
    LoadingSpinnerColor: =RGBA(0, 120, 212, 1)
    OnVisible: |-
        =If(CountIf(col_pbMenu,true)=0,dData.BuildDemoMenus());
        UpdateContext({vert1Menu: "mainVert1"});
        UpdateContext({vert2Menu: "mainVert2"});
        If(IsBlank(fromScreen), 
            UpdateContext({fromScreen: 'pbMenu Demo'})
        );

    Header1 As Header:
        DisplayMode: =DisplayMode.Edit
        Height: =40
        Logo: =stickeromglove
        OnSelectLogo: =Navigate('pbMenu Sandbox',ScreenTransition.Fade)
        Title: =App.ActiveScreen.Name
        TitleRole: =""
        UserEmail: =User().Email
        UserImage: =User().Image
        UserImageAltText: =User().FullName &" profile picture"
        UserName: =User().FullName
        Width: =Parent.Width
        X: =0
        Y: =0
        ZIndex: =1

    MM As pbMenu:
        Collapse: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            If(Self.EnableUserCollapse=false, 
                                false, 
                                pbMenu.DefaultCollapsedState
                            )
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=false, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: true,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:true})
                            )
                        )
                    )
            
                )    
            )
        CollapsedMode: |-
            =//If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal || Self.EnableCollapsedState<>true, false,     
            If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal, false,     
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    If(IsBlank(collapseRec), 
                        pbMenu.DefaultCollapsedState
                        , 
                        collapseRec.boolValue
                    )       
                )
            )
        ConfirmAction: |+
            =With({Perf: {id: GUID(), start: Now(), action: $"CONFIRM ACTION: {p_menuKey}.{p_itemKey} ({p_itemDisplay})"}}, 
                RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm");
                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: p_menuKey,itemKey: p_itemKey, action: "confirm", boolValue: true,  desc: p_itemDisplay});
                If(pbMenu.PerformanceLogging=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
            
        ConfirmMode: =CountIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")>0
        CreateInfoItem: |
            =With({newMenuItem: 
                //get menu item structure
                {
                    menuKey: Upper(TrimEnds(p_menuKey)), 
                    ItemKey: Upper($"_info_{GUID()}"), 
                    ItemDisplayName: TrimEnds(p_itemDisplay), 
                    ItemIconName: "Info", 
                    ItemAppearance: TrimEnds(p_itemAppearance), 
                    ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
                    ItemTooltip: TrimEnds(p_itemTooltip), 
                    ItemDisabled: false, 
                    disableOnSelect: false, 
                    confirmItemAction: false
                }}
                , 
                If(p_addToCollection=true, 
                    RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                    Collect(col_pbMenu,newMenuItem)
                );
                newMenuItem 
            )
        CreateMenuItem: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE MENU ITEM: {p_menuKey}.{p_ItemKey} ({p_ItemDisplayName})"}}, 
                With({isSpacer: (Len(TrimEnds(p_ItemKey))=0)=true},     
                    With({newMenuItem: 
                        If(isSpacer, 
                            //get spacer structure (without adding -- can be added to collection below if appropriate)
                            Self.CreateSpacer(p_menuKey,false), 
                            //get menu item structure
                            {menuKey: Upper(TrimEnds(p_menuKey)), ItemKey: Upper(TrimEnds(Coalesce(p_ItemKey,$"_spacer_{GUID()}"))), ItemDisplayName: If(isSpacer,"",TrimEnds(p_ItemDisplayName)), ItemIconName: If(isSpacer," ", TrimEnds(p_ItemIconName)), ItemAppearance: TrimEnds(p_ItemAppearance), ItemIconStyle: TrimEnds(p_ItemIconStyle), ItemTooltip: TrimEnds(p_ItemTooltip), ItemDisabled: isSpacer, disableOnSelect: p_disableOnSelect, confirmItemAction: p_confirmItemAction}
                        )}, 
                        If(p_addToCollection=true, 
                            RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                            Collect(col_pbMenu,newMenuItem)
                        );
                        If(pbMenu.PerformanceLogging=true, 
                            With({endTS: Now()}, 
                                Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                            )
                        );
                        newMenuItem 
                    )
                )
            )
        CreateSpacer: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE SPACER: {p_menuKey} (Add to collection: {p_addToCollection})"}}, 
                With({newSpacer: 
                    If(Len(TrimEnds(p_menuKey))=0, 
                        Blank(), 
                        {
                            menuKey: Upper(TrimEnds(p_menuKey)), 
                            ItemKey: $"_spacer_{GUID()}", 
                            ItemDisplayName: " ", 
                            ItemIconName: "", 
                            ItemAppearance: Self.ItemAppearanceChoices.Transparent,  
                            ItemIconStyle: Self.ItemIconStyleChoices.Outline, 
                            ItemTooltip: "", 
                            ItemDisabled: true, 
                            disableOnSelect: false, 
                            confirmItemAction: false    
                        }
                    )}, 
                    If(p_addToCollection=true && Not(IsBlank(newSpacer)), 
                        Collect(col_pbMenu,newSpacer)
                    );
                    If(pbMenu.PerformanceLogging=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    );
                    newSpacer
                )
            )
        DoMenu: |
            =    With({mi: pbMenu.MenuItem(p_menuKey,p_itemKey)}, 
                    If(mi.confirmItemAction=true, 
                        If(Self.ConfirmMode() <> true, 
                            //Add 'confirm' action and waits for user to confirm or cancel
                            //cancel clears confirm action
                            //confirm calls DoMenu again, which can then move forward
                            Self.ConfirmAction(p_menuKey,p_itemKey,mi.ItemDisplayName)
                            , 
                            //clear the 'confirm' action, which is now confirmed, and 
                            //process menuItem as normal
                            RemoveIf(col_pbMenuUtil,menuGuid=GUID(MM.ControlGUID) && action="confirm")
                        )
                    );
                    With({doMenuHandled: 
                        If(Self.ConfirmMode() <> true, 
                            If(MM.ManageItemStates = true, 
                                pbMenu.ItemState_UpdateAll(true);
                                If(mi.disableOnSelect=true, 
                                    pbMenu.ItemState(mi.ItemKey,false)
                                )
                            );
                            //Raise 'OnBeforeAction'.  If handled in event on screen ('true' returned), no further action is taken.
                            //If not handled in the 'OnBeforeAction', will attempt to handle below and show error if was not handled.
                            If(Self.OnBeforeAction(p_itemKey) = true, 
                                true
                                , 
                                With({handledHere: 
                                    Switch(Upper(p_itemKey), 
                                        "LAUNCHGITHUB", Launch("https://github.com/lopperman"); true, 
                                        "LAUNCHREDDIT", Launch("https://www.reddit.com/user/ITFuture"); true, 
                                        "GOOGLE", Launch("https://www.google.com"); true, 
                                        //"MINAVPERF", Navigate(PerformanceLog,ScreenTransition.Fade); true, 
            
                                        //not handled
                                        Notify("NO ACTION WAS TAKEN FOR MENU ITEM: " & p_menuKey & "." & p_itemKey & " (" & mi.ItemDisplayName & ")",NotificationType.Error,5000);
                                        false
                                    )}, 
                                    handledHere
                                )
                            );
                        )
                        }, 
                        doMenuHandled
                    )
            
                );
        Expand: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            pbMenu.DefaultCollapsedState
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=true, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: false,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:false})
                            )
                        )
                    )
                )    
            )
        Height: =Self.MinimumHeight()
        Information: |-
            =[
                {
                    name: "About", 
                    type: "General pbMenu Help",
                    desc: "** NOTE: '[pbMenu]' is referenced in this documentation in relation to getting/setting/calling actions for a pbMenu component. Please remember that 'pbMenu' can never be referenced directly from a screen, and should be replaced with the name of the pbMenu component on your screen.  For example, if you added a pbMenu component to your screen, and named it 'mainMenu1', that all interactions for that menu would use 'mainMenu1', and not 'pbMenu'"        
                },
                {
                    name: "ToolbarOrientation", 
                    valText: Self.ToolbarOrientation, 
                    dataType: "Text", 
                    externalUse: "[pbMenu].LayoutChoices.Horizontal (default), or [pbMenu].LayoutChoices.Vertical", 
                    type: "Input Property",
                    desc: "Use to get or set the orientation of [pbMenu]"
                },
                {
                    name: "MinimumHeight()", 
                    valNumber: Self.MinimumHeight(), 
                    dataType: "Number", 
                    externalUse: "When in 'Horizontal' layout mode, set the pbMenu component (added to your screen) 'Height' property to be 'Self.MinimumHeight()'", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Height, when in Horizontal layout mode.  Note: Property 'OverrideMinHeight can be used to fine tune desired menu height."
                },
                {
                    name: "MinimumWidth()", 
                    valNumber: Self.MinimumWidth(), 
                    dataType: "Number", 
                    externalUse: "When in 'Vertical' layout mode, set the pbMenu component (added to your screen) 'Width' property to be 'Self.MinimumWidth()'.  This will enable the pbMenu control to automatically resize when user collapses or expands the menu.", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Width, when in Vertical layout mode,  Note: if you need to adjust the expanded width, use the 'OverrideExpandedWidth' property to set the desired expanded width value"
                },
                {
                    name: "CurrentMenuItems", 
                    valTable: Self.CurrentMenuItems, 
                    dataType: "Table", 
                    externalUse: "Reference Only", 
                    type: "Output Property",
                    desc: "Current Menu Items.   Retrieved by filtering items from 'MenuData' datasource, where menuName=[pbMenu].MenuKey"
                },
                {
                    name: "CancelMenuColorPalette", 
                    valColor: Self.CancelMenuColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Cancel' button; Default is RGBA(0,0,0,0)", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Cancel' button for required user confirmation"
                },
                {
                    name: "CollapseMode()", 
                    valBoolean: Self.CollapsedMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function",
                    desc: "Returns true when 'ToolbarOrientation' is Vertical and menu is collapsed"
                },
                {
                    name: "DefaultCollapsedState", 
                    valBoolean: Self.DefaultCollapsedState, 
                    dataType: "Boolean", 
                    externalUse: "Use to set default collapsed state (true=collapsed, false=expanded)", 
                    type: "Input Property", 
                    desc: "When true, default state of menu will be collapsed, when menu is configured for vertical layout"
                }, 
                {
                    name: "EnableUserCollapse", 
                    valBoolean: Self.EnableUserCollapse, 
                    dataType: "Boolean", 
                    externalUse: "Set to 'false' to prevent vertical menu from ever displaying in collapsed/icon-only mode", 
                    type: "Input Property", 
                    desc: "Defaults to true; controls whether vertical menu can be collapsed"
                }, 
                {
                    name: "ConfirmationColorPalette", 
                    valColor: Self.ConfirmationColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Confirm' button", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Confirm' button for required user confirmation"
                }, 
                {
                    name: "ConfirmMode()", 
                    valBoolean: Self.ConfirmMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function", 
                    desc: "When user has selected a menu item which requires confirmation, [pbMenu].'ConfirmMode()' will return true until user has selected 'Confirm' or 'Cancel'"
                }, 
                {   
                    name: "ControlGUID", 
                    valText: Self.ControlGUID, 
                    dataType: "Text", 
                    externalUse: "Reference Only.  VALUE WILL CHANGE BETWEEN SESSIONS!", 
                    type: "Output Property", 
                    desc: "Unique value which can be used at runtime only, and may update each time a screen becomes visible.  The purpose of this property is to manage specific state information"
                }, 
                {
                    name: "ItemAppearanceChoices", 
                    valRecord: Self.ItemAppearanceChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemAppearance' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property wich can be used when setting value for 'ItemAppearance', when creating a new menu item using [pbMenu].'Create Menu Item'()"
                }, 
                {
                    name: "ItemIconStyleChoices", 
                    valRecord: Self.ItemIconStyleChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemIconStyle' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value for 'ItemIconStyle', when creating a new menu item using [pbMenu].'Create Menu Item'"
                }, 
                {
                    name: "LayoutChoices", 
                    valRecord: Self.LayoutChoices, 
                    dataType: "Record", 
                    externalUse: "Helper used to set valid [pbMenu].ToolbarOrientation", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value of [pbMenu].ToolbarOrientation"
                }, 
                {
                    name: "ConfirmAction", 
                    dataType: "n/a", 
                    externalUse: "Optionally can be used to trigger a menu item selection confirmation (see desc)", 
                    type: "Component Action", 
                    desc: "Trigger action which requires user to confirm or cancel selected menu item.  Used internally by pbMenu when a menu item is selected that was created with 'confirmItemAction' = true. While not intended to be called externally, this action can be triggered outside the pbMenu component as long as the parameter arguments (p_menuKey, p_itemKey, p_itemDisplay) match a menu item which currently is being displayed in [pbMenu]"
                }, 
                {
                    name: "CreateMenuItem", 
                    type: "Component Action", 
                    dataType: "Record", 
                    externalUse: "Returns Menu Item Record data which is also automatically added to collection: col_pbMenu if the 'p_addToCollection' argument is true", 
                    desc: "Returns a menu item record based on provided parameter values.  By default, new menu item is not added to a data source and therefore will not be available for use.  When called with p_addToCollection=true, the new menu item will be added to col_pbMenu (default data source for [pbMenu]), and becomes available for use by any pbMenu component.", 
                    example: $"To get the correct structure (record) of a menu item you wish to add, which will be stored in an external datasource -- like SharePoint or DataVerse -- the following would return that record and NOT add it to the default MenuData datasource ('col_pbMenu'):  [pbMenu].CreateMenuItem({Char(34)}Main{Char(34)},{Char(34)}miNavBuild{Char(34)},{Char(34)}MENU BUILDER{Char(34)},{Char(34)}ArrowRight{Char(34)},[pbMenu].ItemAppearanceChoices.Primary,[pbMenu].ItemIconStyleChoices.Filled,{Char(34)}Build a Menu{Char(34)},false,false,false);, setting the last parameter to 'true' would cause the new menu item to also be added to 'col_pbMenu'"
                }, 
                {
                    name: "DoMenu", 
                    externalUse: "Optionally use to trigger a menu item selection (see desc)", 
                    type: "Component Action", 
                    desc: "Called when user selects a menu item which was rendered from [pbMenu].MenuData data source. Can also be called externally. When a menu item that requires user confirmation is selected, 'DoMenu' is not called until user also selects the confirmation button. When 'DoMenu' is called externally, the item key property is NOT required to correlate to a menu item currently available, as long as the pbMenu being called is able to process the 'p_ItemKey' argument in the [pbMenu].OnBeforeAction event on the current screen."
                }, 
                {
                    name: "ManageItemStates", 
                    valBoolean: Self.ManageItemStates, 
                    dataType: "Boolean", 
                    externalUse: "Used to enable a pbMenu to change menu item states automatically (default: true)", 
                    type: "Input Property", 
                    desc: "When set to true (default), any menu item selected which has 'disableOnSelect' property set to true, will become disabled when selected, and will become re-enabled when any other menu item is selected. When 'ManageItemStates' is set to false, the 'disableOnSelect' menu item property is ignored"
                }, 
                {
                    name: "ItemState", 
                    externalUse: "can be used to manually enable/disable menu items (when [pbMenu].ManageItemStates is false)", 
                    type: "Component Action", 
                    desc: "Used internally by pbMenu to enable/disable a menu item.  Can be called externally to enable/disable a menu item at any time.  Note:  When 'ManageItemStates' is set to true, pbMenu will allways re-enable all menu items when any menu item is selected."
                }, 
                {
                    name: "ItemState_UpdateAll", 
                    type: "Component Action", 
                    desc: "Used internally to re-enable all menu items.  Can be called externally to enable or disable all menu items.  Please remember that when 'ManageItemStates' is set to true, all menu items are enabled any time a menu item is selected.", 
                    canCall: true 
                }, 
                {
                    name: "MenuColorPalette", 
                    valColor: Self.MenuColorPalette, 
                    dataType: "Color", 
                    type: "Input Property", 
                    desc: "Color pallete used for menu items.  Defaults to 'PowerAppsTheme.Colors.Primary'", 
                    canSet: true 
                }, 
                {
                    name: "MenuData_All", 
                    valTable: Self.MenuData_All, 
                    dataType: "Table", 
                    type: "Output Property", 
                    desc: "Unfiltered records from col_pbMenu. This Table/collection contains configuration records for all menu items in all defined menus"
                }, 
                {
                    name: "IsBusy", 
                    valBoolean: Self.IsBusy, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
                {
                    name: "IsBusyEnabled", 
                    valBoolean: Self.IsBusyEnabled, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
            
                {
                    name: "BusyMessage", 
                    valText: Self.BusyMessage, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "The message that is displayed in the pbMenu container, when pbMenu.IsBusy=true, and pbMenu.BusyBehavior='Spinner'."
                }, 
                {
                    name: "BusyBehavior", 
                    valText: Self.BusyBehavior, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Text value to indicate pbMenu behavior when pbMenu.IsBusy=true.  A helper property (pbMenu.BusyBehaviorChoices) can be use to set this property.  Valid value are either 'BusyBehaviorChoices.Spinning' ('Spinning'), or 'BusyBehaviorChoices.Disabled' ('Disabled').  When this property is missing or contains an invalid value, the default value ('Spinning') will be used."
                }, 
                {
                    name: "BusyBehaviorChoices", 
                    valRecord: Self.BusyBehaviorChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which contains valid choices for the pbMenu.BusyBehavior input property"
                }, 
                {
                    name: "ToolbarPadding", 
                    valText: Self.ToolbarPadding, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Toolbar padding is managed automatically ('Medium' for Horizontal Layout, 'Small' for Vertical Layout.)  If adjustment is necessary, can be overridden ('Small', 'Medium', 'Large').  A helper property exists to select choices (ToolbarPaddingChoices).  For example, if the name of your on-screen pbMenu component was 'myMenu' and you wanted to force 'Large' padding, you would set the 'ToolbarPadding' property to: myMenu.ToolbarPaddingChoices.Large"
                }, 
                {
                    name: "ToolbarPaddingChoices", 
                    valRecord: Self.ToolbarPaddingChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which provides valid 'ToolbarPadding' choices"
                }
            
            ]
        IsBusy: =spin.waiting=true
        ItemState: |
            =With({Perf: {id: GUID(), start: Now(), action: $"ITEM STATE CHANGE: {pbMenu.MenuKey}.{p_itemKey} (enabled: {p_enabled})"}}, 
                If(Not(StartsWith(Lower(p_itemKey),"_spacer_")) || Not(p_enabled), 
                    UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey) && Upper(ItemKey)=Upper(p_itemKey),{ItemDisabled:Not(p_enabled)})        
                );
            
            //    RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="disable" && Upper(itemKey)=Upper(p_itemKey));
            //    With({isSpacer:StartsWith(Lower(p_itemKey),"_spacer_")}, 
            //        With({tmpMenuItem: pbMenu.MenuItem(pbMenu.MenuKey,p_itemKey), shouldDisable: If(isSpacer, true, Not(p_enabled))}, 
            //            If(p_enabled=false, 
            //                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: p_itemKey, action: "disable", boolValue: true,  desc: ""});
            //            );
            //            If(tmpMenuItem.ItemDisabled<>shouldDisable, 
            //                Patch(col_pbMenu,tmpMenuItem,{ItemDisabled:shouldDisable})
            //            )
            //        )
            //    );
                If(pbMenu.PerformanceLogging=true && p_enablePerfLog=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
        ItemState_UpdateAll: |
            =With({Perf: {id: GUID(), start: Now(), action: $"UPDATE ITEM STATES (ALL): {pbMenu.MenuKey} (Enabled: {p_Enabled})"}}, 
                UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey),{ItemDisabled:Not(p_Enabled)});
            
            //    ForAll(pbMenu.MenuItems As mItem, 
            //        pbMenu.ItemState(mItem.ItemKey,p_Enabled,false)
            //    );
            
            //    pbMenu.Reset();
            //    If(pbMenu.PerformanceLogging=true, 
            //        With({endTS: Now()}, 
            //            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
            //        )
            //    )
            )
        MenuItem: =LookUp(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_itemKey))
        MinimumHeight: =If(Upper(Self.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Horizontal),If(Self.OverrideMinHeight>0,Self.OverrideMinHeight, 50),140) 
        MinimumWidth: |
            =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal,200,
                If(pbMenu.CollapsedMode()=true,50,
                    If(pbMenu.OverrideExpandedWidth<=0,
                        120, 
                        pbMenu.OverrideExpandedWidth
                    )
                )
            )
        OnBeforeAction: |-
            =Switch(Upper(p_itemKey), 
                Upper("miNavBuild"), Navigate('Menu Builder',ScreenTransition.Fade); true, 
                Upper("togglePerfLogging"), 
                    Set(pbMenu_LogPerformance,Not(pbMenu_LogPerformance));
                    Notify($"'pbMenu_LogPerformance' global variable is now set to: {pbMenu_LogPerformance}.  Any pbMenu using 'pbMenu_LogPerformance' for the Log Performance property will now use this value",NotificationType.Information,5000);
                    true, 
                Upper("miNavPerf"),  Navigate(PerformanceLog,ScreenTransition.Fade); true, 
                
                false 
            )
        OnRemoveMenuItem: =
        PerformanceLogging: =pbMenu_LogPerformance
        RemoveMenuItem: |-
            =RemoveIf(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_menuItemKey));
            Self.OnRemoveMenuItem(p_menuKey,p_menuItemKey)
        Reset: =Reset(MM)
        ShowNavBackButton: =fromScreen.Name <> 'pbMenu Demo'.Name
        ToolbarOrientation: =MM.LayoutChoices.Horizontal
        ToolbarPadding: =If(Upper(MM.ToolbarOrientation)=Upper(MM.LayoutChoices.Horizontal), 'Toolbar.Padding'.Medium,  'Toolbar.Padding'.Small)
        Width: =Parent.Width
        Y: =Header1.Y + Header1.Height
        ZIndex: =2

    pbMenu_Vert As pbMenu:
        Collapse: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            If(Self.EnableUserCollapse=false, 
                                false, 
                                pbMenu.DefaultCollapsedState
                            )
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=false, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: true,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:true})
                            )
                        )
                    )
            
                )    
            )
        CollapsedMode: |-
            =//If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal || Self.EnableCollapsedState<>true, false,     
            If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal, false,     
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    If(IsBlank(collapseRec), 
                        pbMenu.DefaultCollapsedState
                        , 
                        collapseRec.boolValue
                    )       
                )
            )
        ConfirmAction: |+
            =With({Perf: {id: GUID(), start: Now(), action: $"CONFIRM ACTION: {p_menuKey}.{p_itemKey} ({p_itemDisplay})"}}, 
                RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm");
                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: p_menuKey,itemKey: p_itemKey, action: "confirm", boolValue: true,  desc: p_itemDisplay});
                If(pbMenu.PerformanceLogging=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
            
        ConfirmMode: =CountIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")>0
        CreateInfoItem: |
            =With({newMenuItem: 
                //get menu item structure
                {
                    menuKey: Upper(TrimEnds(p_menuKey)), 
                    ItemKey: Upper($"_info_{GUID()}"), 
                    ItemDisplayName: TrimEnds(p_itemDisplay), 
                    ItemIconName: "Info", 
                    ItemAppearance: TrimEnds(p_itemAppearance), 
                    ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
                    ItemTooltip: TrimEnds(p_itemTooltip), 
                    ItemDisabled: false, 
                    disableOnSelect: false, 
                    confirmItemAction: false
                }}
                , 
                If(p_addToCollection=true, 
                    RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                    Collect(col_pbMenu,newMenuItem)
                );
                newMenuItem 
            )
        CreateMenuItem: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE MENU ITEM: {p_menuKey}.{p_ItemKey} ({p_ItemDisplayName})"}}, 
                With({isSpacer: (Len(TrimEnds(p_ItemKey))=0)=true},     
                    With({newMenuItem: 
                        If(isSpacer, 
                            //get spacer structure (without adding -- can be added to collection below if appropriate)
                            Self.CreateSpacer(p_menuKey,false), 
                            //get menu item structure
                            {menuKey: Upper(TrimEnds(p_menuKey)), ItemKey: Upper(TrimEnds(Coalesce(p_ItemKey,$"_spacer_{GUID()}"))), ItemDisplayName: If(isSpacer,"",TrimEnds(p_ItemDisplayName)), ItemIconName: If(isSpacer," ", TrimEnds(p_ItemIconName)), ItemAppearance: TrimEnds(p_ItemAppearance), ItemIconStyle: TrimEnds(p_ItemIconStyle), ItemTooltip: TrimEnds(p_ItemTooltip), ItemDisabled: isSpacer, disableOnSelect: p_disableOnSelect, confirmItemAction: p_confirmItemAction}
                        )}, 
                        If(p_addToCollection=true, 
                            RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                            Collect(col_pbMenu,newMenuItem)
                        );
                        If(pbMenu.PerformanceLogging=true, 
                            With({endTS: Now()}, 
                                Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                            )
                        );
                        newMenuItem 
                    )
                )
            )
        CreateSpacer: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE SPACER: {p_menuKey} (Add to collection: {p_addToCollection})"}}, 
                With({newSpacer: 
                    If(Len(TrimEnds(p_menuKey))=0, 
                        Blank(), 
                        {
                            menuKey: Upper(TrimEnds(p_menuKey)), 
                            ItemKey: $"_spacer_{GUID()}", 
                            ItemDisplayName: " ", 
                            ItemIconName: "", 
                            ItemAppearance: Self.ItemAppearanceChoices.Transparent,  
                            ItemIconStyle: Self.ItemIconStyleChoices.Outline, 
                            ItemTooltip: "", 
                            ItemDisabled: true, 
                            disableOnSelect: false, 
                            confirmItemAction: false    
                        }
                    )}, 
                    If(p_addToCollection=true && Not(IsBlank(newSpacer)), 
                        Collect(col_pbMenu,newSpacer)
                    );
                    If(pbMenu.PerformanceLogging=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    );
                    newSpacer
                )
            )
        DoMenu: |
            =    With({mi: pbMenu.MenuItem(p_menuKey,p_itemKey)}, 
                    If(mi.confirmItemAction=true, 
                        If(Self.ConfirmMode() <> true, 
                            //Add 'confirm' action and waits for user to confirm or cancel
                            //cancel clears confirm action
                            //confirm calls DoMenu again, which can then move forward
                            Self.ConfirmAction(p_menuKey,p_itemKey,mi.ItemDisplayName)
                            , 
                            //clear the 'confirm' action, which is now confirmed, and 
                            //process menuItem as normal
                            RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu_Vert.ControlGUID) && action="confirm")
                        )
                    );
                    With({doMenuHandled: 
                        If(Self.ConfirmMode() <> true, 
                            If(pbMenu_Vert.ManageItemStates = true, 
                                pbMenu.ItemState_UpdateAll(true);
                                If(mi.disableOnSelect=true, 
                                    pbMenu.ItemState(mi.ItemKey,false)
                                )
                            );
                            //Raise 'OnBeforeAction'.  If handled in event on screen ('true' returned), no further action is taken.
                            //If not handled in the 'OnBeforeAction', will attempt to handle below and show error if was not handled.
                            If(Self.OnBeforeAction(p_itemKey) = true, 
                                true
                                , 
                                With({handledHere: 
                                    Switch(Upper(p_itemKey), 
                                        "LAUNCHGITHUB", Launch("https://github.com/lopperman"); true, 
                                        "LAUNCHREDDIT", Launch("https://www.reddit.com/user/ITFuture"); true, 
                                        "GOOGLE", Launch("https://www.google.com"); true, 
                                        //"MINAVPERF", Navigate(PerformanceLog,ScreenTransition.Fade); true, 
            
                                        //not handled
                                        Notify("NO ACTION WAS TAKEN FOR MENU ITEM: " & p_menuKey & "." & p_itemKey & " (" & mi.ItemDisplayName & ")",NotificationType.Error,5000);
                                        false
                                    )}, 
                                    handledHere
                                )
                            );
                        )
                        }, 
                        doMenuHandled
                    )
            
                );
        Expand: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            pbMenu.DefaultCollapsedState
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=true, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: false,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:false})
                            )
                        )
                    )
                )    
            )
        Fill: =RGBA(214, 221, 224, 1)
        Height: =Parent.Height - Self.Y -8
        Information: |-
            =[
                {
                    name: "About", 
                    type: "General pbMenu Help",
                    desc: "** NOTE: '[pbMenu]' is referenced in this documentation in relation to getting/setting/calling actions for a pbMenu component. Please remember that 'pbMenu' can never be referenced directly from a screen, and should be replaced with the name of the pbMenu component on your screen.  For example, if you added a pbMenu component to your screen, and named it 'mainMenu1', that all interactions for that menu would use 'mainMenu1', and not 'pbMenu'"        
                },
                {
                    name: "ToolbarOrientation", 
                    valText: Self.ToolbarOrientation, 
                    dataType: "Text", 
                    externalUse: "[pbMenu].LayoutChoices.Horizontal (default), or [pbMenu].LayoutChoices.Vertical", 
                    type: "Input Property",
                    desc: "Use to get or set the orientation of [pbMenu]"
                },
                {
                    name: "MinimumHeight()", 
                    valNumber: Self.MinimumHeight(), 
                    dataType: "Number", 
                    externalUse: "When in 'Horizontal' layout mode, set the pbMenu component (added to your screen) 'Height' property to be 'Self.MinimumHeight()'", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Height, when in Horizontal layout mode.  Note: Property 'OverrideMinHeight can be used to fine tune desired menu height."
                },
                {
                    name: "MinimumWidth()", 
                    valNumber: Self.MinimumWidth(), 
                    dataType: "Number", 
                    externalUse: "When in 'Vertical' layout mode, set the pbMenu component (added to your screen) 'Width' property to be 'Self.MinimumWidth()'.  This will enable the pbMenu control to automatically resize when user collapses or expands the menu.", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Width, when in Vertical layout mode,  Note: if you need to adjust the expanded width, use the 'OverrideExpandedWidth' property to set the desired expanded width value"
                },
                {
                    name: "CurrentMenuItems", 
                    valTable: Self.CurrentMenuItems, 
                    dataType: "Table", 
                    externalUse: "Reference Only", 
                    type: "Output Property",
                    desc: "Current Menu Items.   Retrieved by filtering items from 'MenuData' datasource, where menuName=[pbMenu].MenuKey"
                },
                {
                    name: "CancelMenuColorPalette", 
                    valColor: Self.CancelMenuColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Cancel' button; Default is RGBA(0,0,0,0)", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Cancel' button for required user confirmation"
                },
                {
                    name: "CollapseMode()", 
                    valBoolean: Self.CollapsedMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function",
                    desc: "Returns true when 'ToolbarOrientation' is Vertical and menu is collapsed"
                },
                {
                    name: "DefaultCollapsedState", 
                    valBoolean: Self.DefaultCollapsedState, 
                    dataType: "Boolean", 
                    externalUse: "Use to set default collapsed state (true=collapsed, false=expanded)", 
                    type: "Input Property", 
                    desc: "When true, default state of menu will be collapsed, when menu is configured for vertical layout"
                }, 
                {
                    name: "EnableUserCollapse", 
                    valBoolean: Self.EnableUserCollapse, 
                    dataType: "Boolean", 
                    externalUse: "Set to 'false' to prevent vertical menu from ever displaying in collapsed/icon-only mode", 
                    type: "Input Property", 
                    desc: "Defaults to true; controls whether vertical menu can be collapsed"
                }, 
                {
                    name: "ConfirmationColorPalette", 
                    valColor: Self.ConfirmationColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Confirm' button", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Confirm' button for required user confirmation"
                }, 
                {
                    name: "ConfirmMode()", 
                    valBoolean: Self.ConfirmMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function", 
                    desc: "When user has selected a menu item which requires confirmation, [pbMenu].'ConfirmMode()' will return true until user has selected 'Confirm' or 'Cancel'"
                }, 
                {   
                    name: "ControlGUID", 
                    valText: Self.ControlGUID, 
                    dataType: "Text", 
                    externalUse: "Reference Only.  VALUE WILL CHANGE BETWEEN SESSIONS!", 
                    type: "Output Property", 
                    desc: "Unique value which can be used at runtime only, and may update each time a screen becomes visible.  The purpose of this property is to manage specific state information"
                }, 
                {
                    name: "ItemAppearanceChoices", 
                    valRecord: Self.ItemAppearanceChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemAppearance' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property wich can be used when setting value for 'ItemAppearance', when creating a new menu item using [pbMenu].'Create Menu Item'()"
                }, 
                {
                    name: "ItemIconStyleChoices", 
                    valRecord: Self.ItemIconStyleChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemIconStyle' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value for 'ItemIconStyle', when creating a new menu item using [pbMenu].'Create Menu Item'"
                }, 
                {
                    name: "LayoutChoices", 
                    valRecord: Self.LayoutChoices, 
                    dataType: "Record", 
                    externalUse: "Helper used to set valid [pbMenu].ToolbarOrientation", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value of [pbMenu].ToolbarOrientation"
                }, 
                {
                    name: "ConfirmAction", 
                    dataType: "n/a", 
                    externalUse: "Optionally can be used to trigger a menu item selection confirmation (see desc)", 
                    type: "Component Action", 
                    desc: "Trigger action which requires user to confirm or cancel selected menu item.  Used internally by pbMenu when a menu item is selected that was created with 'confirmItemAction' = true. While not intended to be called externally, this action can be triggered outside the pbMenu component as long as the parameter arguments (p_menuKey, p_itemKey, p_itemDisplay) match a menu item which currently is being displayed in [pbMenu]"
                }, 
                {
                    name: "CreateMenuItem", 
                    type: "Component Action", 
                    dataType: "Record", 
                    externalUse: "Returns Menu Item Record data which is also automatically added to collection: col_pbMenu if the 'p_addToCollection' argument is true", 
                    desc: "Returns a menu item record based on provided parameter values.  By default, new menu item is not added to a data source and therefore will not be available for use.  When called with p_addToCollection=true, the new menu item will be added to col_pbMenu (default data source for [pbMenu]), and becomes available for use by any pbMenu component.", 
                    example: $"To get the correct structure (record) of a menu item you wish to add, which will be stored in an external datasource -- like SharePoint or DataVerse -- the following would return that record and NOT add it to the default MenuData datasource ('col_pbMenu'):  [pbMenu].CreateMenuItem({Char(34)}Main{Char(34)},{Char(34)}miNavBuild{Char(34)},{Char(34)}MENU BUILDER{Char(34)},{Char(34)}ArrowRight{Char(34)},[pbMenu].ItemAppearanceChoices.Primary,[pbMenu].ItemIconStyleChoices.Filled,{Char(34)}Build a Menu{Char(34)},false,false,false);, setting the last parameter to 'true' would cause the new menu item to also be added to 'col_pbMenu'"
                }, 
                {
                    name: "DoMenu", 
                    externalUse: "Optionally use to trigger a menu item selection (see desc)", 
                    type: "Component Action", 
                    desc: "Called when user selects a menu item which was rendered from [pbMenu].MenuData data source. Can also be called externally. When a menu item that requires user confirmation is selected, 'DoMenu' is not called until user also selects the confirmation button. When 'DoMenu' is called externally, the item key property is NOT required to correlate to a menu item currently available, as long as the pbMenu being called is able to process the 'p_ItemKey' argument in the [pbMenu].OnBeforeAction event on the current screen."
                }, 
                {
                    name: "ManageItemStates", 
                    valBoolean: Self.ManageItemStates, 
                    dataType: "Boolean", 
                    externalUse: "Used to enable a pbMenu to change menu item states automatically (default: true)", 
                    type: "Input Property", 
                    desc: "When set to true (default), any menu item selected which has 'disableOnSelect' property set to true, will become disabled when selected, and will become re-enabled when any other menu item is selected. When 'ManageItemStates' is set to false, the 'disableOnSelect' menu item property is ignored"
                }, 
                {
                    name: "ItemState", 
                    externalUse: "can be used to manually enable/disable menu items (when [pbMenu].ManageItemStates is false)", 
                    type: "Component Action", 
                    desc: "Used internally by pbMenu to enable/disable a menu item.  Can be called externally to enable/disable a menu item at any time.  Note:  When 'ManageItemStates' is set to true, pbMenu will allways re-enable all menu items when any menu item is selected."
                }, 
                {
                    name: "ItemState_UpdateAll", 
                    type: "Component Action", 
                    desc: "Used internally to re-enable all menu items.  Can be called externally to enable or disable all menu items.  Please remember that when 'ManageItemStates' is set to true, all menu items are enabled any time a menu item is selected.", 
                    canCall: true 
                }, 
                {
                    name: "MenuColorPalette", 
                    valColor: Self.MenuColorPalette, 
                    dataType: "Color", 
                    type: "Input Property", 
                    desc: "Color pallete used for menu items.  Defaults to 'PowerAppsTheme.Colors.Primary'", 
                    canSet: true 
                }, 
                {
                    name: "MenuData_All", 
                    valTable: Self.MenuData_All, 
                    dataType: "Table", 
                    type: "Output Property", 
                    desc: "Unfiltered records from col_pbMenu. This Table/collection contains configuration records for all menu items in all defined menus"
                }, 
                {
                    name: "IsBusy", 
                    valBoolean: Self.IsBusy, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
                {
                    name: "IsBusyEnabled", 
                    valBoolean: Self.IsBusyEnabled, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
            
                {
                    name: "BusyMessage", 
                    valText: Self.BusyMessage, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "The message that is displayed in the pbMenu container, when pbMenu.IsBusy=true, and pbMenu.BusyBehavior='Spinner'."
                }, 
                {
                    name: "BusyBehavior", 
                    valText: Self.BusyBehavior, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Text value to indicate pbMenu behavior when pbMenu.IsBusy=true.  A helper property (pbMenu.BusyBehaviorChoices) can be use to set this property.  Valid value are either 'BusyBehaviorChoices.Spinning' ('Spinning'), or 'BusyBehaviorChoices.Disabled' ('Disabled').  When this property is missing or contains an invalid value, the default value ('Spinning') will be used."
                }, 
                {
                    name: "BusyBehaviorChoices", 
                    valRecord: Self.BusyBehaviorChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which contains valid choices for the pbMenu.BusyBehavior input property"
                }, 
                {
                    name: "ToolbarPadding", 
                    valText: Self.ToolbarPadding, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Toolbar padding is managed automatically ('Medium' for Horizontal Layout, 'Small' for Vertical Layout.)  If adjustment is necessary, can be overridden ('Small', 'Medium', 'Large').  A helper property exists to select choices (ToolbarPaddingChoices).  For example, if the name of your on-screen pbMenu component was 'myMenu' and you wanted to force 'Large' padding, you would set the 'ToolbarPadding' property to: myMenu.ToolbarPaddingChoices.Large"
                }, 
                {
                    name: "ToolbarPaddingChoices", 
                    valRecord: Self.ToolbarPaddingChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which provides valid 'ToolbarPadding' choices"
                }
            
            ]
        IsBusy: =spin.waiting=true
        ItemState: |
            =With({Perf: {id: GUID(), start: Now(), action: $"ITEM STATE CHANGE: {pbMenu.MenuKey}.{p_itemKey} (enabled: {p_enabled})"}}, 
                If(Not(StartsWith(Lower(p_itemKey),"_spacer_")) || Not(p_enabled), 
                    UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey) && Upper(ItemKey)=Upper(p_itemKey),{ItemDisabled:Not(p_enabled)})        
                );
            
            //    RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="disable" && Upper(itemKey)=Upper(p_itemKey));
            //    With({isSpacer:StartsWith(Lower(p_itemKey),"_spacer_")}, 
            //        With({tmpMenuItem: pbMenu.MenuItem(pbMenu.MenuKey,p_itemKey), shouldDisable: If(isSpacer, true, Not(p_enabled))}, 
            //            If(p_enabled=false, 
            //                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: p_itemKey, action: "disable", boolValue: true,  desc: ""});
            //            );
            //            If(tmpMenuItem.ItemDisabled<>shouldDisable, 
            //                Patch(col_pbMenu,tmpMenuItem,{ItemDisabled:shouldDisable})
            //            )
            //        )
            //    );
                If(pbMenu.PerformanceLogging=true && p_enablePerfLog=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
        ItemState_UpdateAll: |
            =With({Perf: {id: GUID(), start: Now(), action: $"UPDATE ITEM STATES (ALL): {pbMenu.MenuKey} (Enabled: {p_Enabled})"}}, 
                UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey),{ItemDisabled:Not(p_Enabled)});
            
            //    ForAll(pbMenu.MenuItems As mItem, 
            //        pbMenu.ItemState(mItem.ItemKey,p_Enabled,false)
            //    );
            
            //    pbMenu.Reset();
            //    If(pbMenu.PerformanceLogging=true, 
            //        With({endTS: Now()}, 
            //            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
            //        )
            //    )
            )
        MenuColorPalette: =RGBA(189, 49, 51, 1)
        MenuItem: =LookUp(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_itemKey))
        MenuKey: =vert1Menu
        MinimumHeight: =If(Upper(Self.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Horizontal),If(Self.OverrideMinHeight>0,Self.OverrideMinHeight, 50),140) 
        MinimumWidth: |
            =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal,200,
                If(pbMenu.CollapsedMode()=true,50,
                    If(pbMenu.OverrideExpandedWidth<=0,
                        120, 
                        pbMenu.OverrideExpandedWidth
                    )
                )
            )
        OnBeforeAction: |
            =Set(spin,{waiting: true,msg: $"Busy, please wait: {Text(Now(),"hh:mm:ss am/pm")}"});
            With({handled: 
                Switch(Upper(p_itemKey), 
                    Upper("useMenu_mainVert1"), UpdateContext({vert1Menu:"mainVert1"}); Self.ItemState_UpdateAll(true); true, 
                    Upper("useMenu_mainVert2"), UpdateContext({vert1Menu:"mainVert2"}); Self.ItemState_UpdateAll(true); true, 
                    Upper("disableOtherMenus"), MM.ItemState_UpdateAll(false); pbMenu_Vert_1.ItemState_UpdateAll(false); true, 
                    Upper("enableOtherMenus"), MM.ItemState_UpdateAll(true); pbMenu_Vert_1.ItemState_UpdateAll(true); true, 
            
                    false
                )},
            //    If(Not(handled), 
            //        Notify($"Normally, this menu item ({Self.MenuKey}.{p_itemKey}) would be wired up to something!",NotificationType.Information,2000)
            //    );
                //add false here to route request back to pbMenu action handler
                handled  
            );
            Set(spin,Blank());
            
                    
        OnRemoveMenuItem: =
        OverrideExpandedWidth: =160
        PerformanceLogging: =pbMenu_LogPerformance
        RemoveMenuItem: |-
            =RemoveIf(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_menuItemKey));
            Self.OnRemoveMenuItem(p_menuKey,p_menuItemKey)
        Reset: =Reset(pbMenu_Vert)
        ToolbarOrientation: =pbMenu_Vert.LayoutChoices.Vertical
        Width: =Self.MinimumWidth()
        Y: =MM.Y + MM.Height + 10 
        ZIndex: =3

    pbMenu_Vert_1 As pbMenu:
        BorderColor: =PowerAppsTheme.Colors.Lighter50
        BusyBehavior: =Self.BusyBehaviorChoices.Disabled
        Collapse: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            If(Self.EnableUserCollapse=false, 
                                false, 
                                pbMenu.DefaultCollapsedState
                            )
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=false, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: true,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:true})
                            )
                        )
                    )
            
                )    
            )
        CollapsedMode: |-
            =//If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal || Self.EnableCollapsedState<>true, false,     
            If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal, false,     
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    If(IsBlank(collapseRec), 
                        pbMenu.DefaultCollapsedState
                        , 
                        collapseRec.boolValue
                    )       
                )
            )
        ConfirmAction: |+
            =With({Perf: {id: GUID(), start: Now(), action: $"CONFIRM ACTION: {p_menuKey}.{p_itemKey} ({p_itemDisplay})"}}, 
                RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm");
                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: p_menuKey,itemKey: p_itemKey, action: "confirm", boolValue: true,  desc: p_itemDisplay});
                If(pbMenu.PerformanceLogging=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
            
        ConfirmMode: =CountIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")>0
        CreateInfoItem: |
            =With({newMenuItem: 
                //get menu item structure
                {
                    menuKey: Upper(TrimEnds(p_menuKey)), 
                    ItemKey: Upper($"_info_{GUID()}"), 
                    ItemDisplayName: TrimEnds(p_itemDisplay), 
                    ItemIconName: "Info", 
                    ItemAppearance: TrimEnds(p_itemAppearance), 
                    ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
                    ItemTooltip: TrimEnds(p_itemTooltip), 
                    ItemDisabled: false, 
                    disableOnSelect: false, 
                    confirmItemAction: false
                }}
                , 
                If(p_addToCollection=true, 
                    RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                    Collect(col_pbMenu,newMenuItem)
                );
                newMenuItem 
            )
        CreateMenuItem: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE MENU ITEM: {p_menuKey}.{p_ItemKey} ({p_ItemDisplayName})"}}, 
                With({isSpacer: (Len(TrimEnds(p_ItemKey))=0)=true},     
                    With({newMenuItem: 
                        If(isSpacer, 
                            //get spacer structure (without adding -- can be added to collection below if appropriate)
                            Self.CreateSpacer(p_menuKey,false), 
                            //get menu item structure
                            {menuKey: Upper(TrimEnds(p_menuKey)), ItemKey: Upper(TrimEnds(Coalesce(p_ItemKey,$"_spacer_{GUID()}"))), ItemDisplayName: If(isSpacer,"",TrimEnds(p_ItemDisplayName)), ItemIconName: If(isSpacer," ", TrimEnds(p_ItemIconName)), ItemAppearance: TrimEnds(p_ItemAppearance), ItemIconStyle: TrimEnds(p_ItemIconStyle), ItemTooltip: TrimEnds(p_ItemTooltip), ItemDisabled: isSpacer, disableOnSelect: p_disableOnSelect, confirmItemAction: p_confirmItemAction}
                        )}, 
                        If(p_addToCollection=true, 
                            RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                            Collect(col_pbMenu,newMenuItem)
                        );
                        If(pbMenu.PerformanceLogging=true, 
                            With({endTS: Now()}, 
                                Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                            )
                        );
                        newMenuItem 
                    )
                )
            )
        CreateSpacer: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE SPACER: {p_menuKey} (Add to collection: {p_addToCollection})"}}, 
                With({newSpacer: 
                    If(Len(TrimEnds(p_menuKey))=0, 
                        Blank(), 
                        {
                            menuKey: Upper(TrimEnds(p_menuKey)), 
                            ItemKey: $"_spacer_{GUID()}", 
                            ItemDisplayName: " ", 
                            ItemIconName: "", 
                            ItemAppearance: Self.ItemAppearanceChoices.Transparent,  
                            ItemIconStyle: Self.ItemIconStyleChoices.Outline, 
                            ItemTooltip: "", 
                            ItemDisabled: true, 
                            disableOnSelect: false, 
                            confirmItemAction: false    
                        }
                    )}, 
                    If(p_addToCollection=true && Not(IsBlank(newSpacer)), 
                        Collect(col_pbMenu,newSpacer)
                    );
                    If(pbMenu.PerformanceLogging=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    );
                    newSpacer
                )
            )
        DoMenu: |
            =    With({mi: pbMenu.MenuItem(p_menuKey,p_itemKey)}, 
                    If(mi.confirmItemAction=true, 
                        If(Self.ConfirmMode() <> true, 
                            //Add 'confirm' action and waits for user to confirm or cancel
                            //cancel clears confirm action
                            //confirm calls DoMenu again, which can then move forward
                            Self.ConfirmAction(p_menuKey,p_itemKey,mi.ItemDisplayName)
                            , 
                            //clear the 'confirm' action, which is now confirmed, and 
                            //process menuItem as normal
                            RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu_Vert_1.ControlGUID) && action="confirm")
                        )
                    );
                    With({doMenuHandled: 
                        If(Self.ConfirmMode() <> true, 
                            If(pbMenu_Vert_1.ManageItemStates = true, 
                                pbMenu.ItemState_UpdateAll(true);
                                If(mi.disableOnSelect=true, 
                                    pbMenu.ItemState(mi.ItemKey,false)
                                )
                            );
                            //Raise 'OnBeforeAction'.  If handled in event on screen ('true' returned), no further action is taken.
                            //If not handled in the 'OnBeforeAction', will attempt to handle below and show error if was not handled.
                            If(Self.OnBeforeAction(p_itemKey) = true, 
                                true
                                , 
                                With({handledHere: 
                                    Switch(Upper(p_itemKey), 
                                        "LAUNCHGITHUB", Launch("https://github.com/lopperman"); true, 
                                        "LAUNCHREDDIT", Launch("https://www.reddit.com/user/ITFuture"); true, 
                                        "GOOGLE", Launch("https://www.google.com"); true, 
                                        //"MINAVPERF", Navigate(PerformanceLog,ScreenTransition.Fade); true, 
            
                                        //not handled
                                        Notify("NO ACTION WAS TAKEN FOR MENU ITEM: " & p_menuKey & "." & p_itemKey & " (" & mi.ItemDisplayName & ")",NotificationType.Error,5000);
                                        false
                                    )}, 
                                    handledHere
                                )
                            );
                        )
                        }, 
                        doMenuHandled
                    )
            
                );
        Expand: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            pbMenu.DefaultCollapsedState
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=true, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: false,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:false})
                            )
                        )
                    )
                )    
            )
        Fill: =RGBA(252, 252, 217, 1)
        Height: =Parent.Height - Self.Y -8
        Information: |-
            =[
                {
                    name: "About", 
                    type: "General pbMenu Help",
                    desc: "** NOTE: '[pbMenu]' is referenced in this documentation in relation to getting/setting/calling actions for a pbMenu component. Please remember that 'pbMenu' can never be referenced directly from a screen, and should be replaced with the name of the pbMenu component on your screen.  For example, if you added a pbMenu component to your screen, and named it 'mainMenu1', that all interactions for that menu would use 'mainMenu1', and not 'pbMenu'"        
                },
                {
                    name: "ToolbarOrientation", 
                    valText: Self.ToolbarOrientation, 
                    dataType: "Text", 
                    externalUse: "[pbMenu].LayoutChoices.Horizontal (default), or [pbMenu].LayoutChoices.Vertical", 
                    type: "Input Property",
                    desc: "Use to get or set the orientation of [pbMenu]"
                },
                {
                    name: "MinimumHeight()", 
                    valNumber: Self.MinimumHeight(), 
                    dataType: "Number", 
                    externalUse: "When in 'Horizontal' layout mode, set the pbMenu component (added to your screen) 'Height' property to be 'Self.MinimumHeight()'", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Height, when in Horizontal layout mode.  Note: Property 'OverrideMinHeight can be used to fine tune desired menu height."
                },
                {
                    name: "MinimumWidth()", 
                    valNumber: Self.MinimumWidth(), 
                    dataType: "Number", 
                    externalUse: "When in 'Vertical' layout mode, set the pbMenu component (added to your screen) 'Width' property to be 'Self.MinimumWidth()'.  This will enable the pbMenu control to automatically resize when user collapses or expands the menu.", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Width, when in Vertical layout mode,  Note: if you need to adjust the expanded width, use the 'OverrideExpandedWidth' property to set the desired expanded width value"
                },
                {
                    name: "CurrentMenuItems", 
                    valTable: Self.CurrentMenuItems, 
                    dataType: "Table", 
                    externalUse: "Reference Only", 
                    type: "Output Property",
                    desc: "Current Menu Items.   Retrieved by filtering items from 'MenuData' datasource, where menuName=[pbMenu].MenuKey"
                },
                {
                    name: "CancelMenuColorPalette", 
                    valColor: Self.CancelMenuColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Cancel' button; Default is RGBA(0,0,0,0)", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Cancel' button for required user confirmation"
                },
                {
                    name: "CollapseMode()", 
                    valBoolean: Self.CollapsedMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function",
                    desc: "Returns true when 'ToolbarOrientation' is Vertical and menu is collapsed"
                },
                {
                    name: "DefaultCollapsedState", 
                    valBoolean: Self.DefaultCollapsedState, 
                    dataType: "Boolean", 
                    externalUse: "Use to set default collapsed state (true=collapsed, false=expanded)", 
                    type: "Input Property", 
                    desc: "When true, default state of menu will be collapsed, when menu is configured for vertical layout"
                }, 
                {
                    name: "EnableUserCollapse", 
                    valBoolean: Self.EnableUserCollapse, 
                    dataType: "Boolean", 
                    externalUse: "Set to 'false' to prevent vertical menu from ever displaying in collapsed/icon-only mode", 
                    type: "Input Property", 
                    desc: "Defaults to true; controls whether vertical menu can be collapsed"
                }, 
                {
                    name: "ConfirmationColorPalette", 
                    valColor: Self.ConfirmationColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Confirm' button", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Confirm' button for required user confirmation"
                }, 
                {
                    name: "ConfirmMode()", 
                    valBoolean: Self.ConfirmMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function", 
                    desc: "When user has selected a menu item which requires confirmation, [pbMenu].'ConfirmMode()' will return true until user has selected 'Confirm' or 'Cancel'"
                }, 
                {   
                    name: "ControlGUID", 
                    valText: Self.ControlGUID, 
                    dataType: "Text", 
                    externalUse: "Reference Only.  VALUE WILL CHANGE BETWEEN SESSIONS!", 
                    type: "Output Property", 
                    desc: "Unique value which can be used at runtime only, and may update each time a screen becomes visible.  The purpose of this property is to manage specific state information"
                }, 
                {
                    name: "ItemAppearanceChoices", 
                    valRecord: Self.ItemAppearanceChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemAppearance' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property wich can be used when setting value for 'ItemAppearance', when creating a new menu item using [pbMenu].'Create Menu Item'()"
                }, 
                {
                    name: "ItemIconStyleChoices", 
                    valRecord: Self.ItemIconStyleChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemIconStyle' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value for 'ItemIconStyle', when creating a new menu item using [pbMenu].'Create Menu Item'"
                }, 
                {
                    name: "LayoutChoices", 
                    valRecord: Self.LayoutChoices, 
                    dataType: "Record", 
                    externalUse: "Helper used to set valid [pbMenu].ToolbarOrientation", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value of [pbMenu].ToolbarOrientation"
                }, 
                {
                    name: "ConfirmAction", 
                    dataType: "n/a", 
                    externalUse: "Optionally can be used to trigger a menu item selection confirmation (see desc)", 
                    type: "Component Action", 
                    desc: "Trigger action which requires user to confirm or cancel selected menu item.  Used internally by pbMenu when a menu item is selected that was created with 'confirmItemAction' = true. While not intended to be called externally, this action can be triggered outside the pbMenu component as long as the parameter arguments (p_menuKey, p_itemKey, p_itemDisplay) match a menu item which currently is being displayed in [pbMenu]"
                }, 
                {
                    name: "CreateMenuItem", 
                    type: "Component Action", 
                    dataType: "Record", 
                    externalUse: "Returns Menu Item Record data which is also automatically added to collection: col_pbMenu if the 'p_addToCollection' argument is true", 
                    desc: "Returns a menu item record based on provided parameter values.  By default, new menu item is not added to a data source and therefore will not be available for use.  When called with p_addToCollection=true, the new menu item will be added to col_pbMenu (default data source for [pbMenu]), and becomes available for use by any pbMenu component.", 
                    example: $"To get the correct structure (record) of a menu item you wish to add, which will be stored in an external datasource -- like SharePoint or DataVerse -- the following would return that record and NOT add it to the default MenuData datasource ('col_pbMenu'):  [pbMenu].CreateMenuItem({Char(34)}Main{Char(34)},{Char(34)}miNavBuild{Char(34)},{Char(34)}MENU BUILDER{Char(34)},{Char(34)}ArrowRight{Char(34)},[pbMenu].ItemAppearanceChoices.Primary,[pbMenu].ItemIconStyleChoices.Filled,{Char(34)}Build a Menu{Char(34)},false,false,false);, setting the last parameter to 'true' would cause the new menu item to also be added to 'col_pbMenu'"
                }, 
                {
                    name: "DoMenu", 
                    externalUse: "Optionally use to trigger a menu item selection (see desc)", 
                    type: "Component Action", 
                    desc: "Called when user selects a menu item which was rendered from [pbMenu].MenuData data source. Can also be called externally. When a menu item that requires user confirmation is selected, 'DoMenu' is not called until user also selects the confirmation button. When 'DoMenu' is called externally, the item key property is NOT required to correlate to a menu item currently available, as long as the pbMenu being called is able to process the 'p_ItemKey' argument in the [pbMenu].OnBeforeAction event on the current screen."
                }, 
                {
                    name: "ManageItemStates", 
                    valBoolean: Self.ManageItemStates, 
                    dataType: "Boolean", 
                    externalUse: "Used to enable a pbMenu to change menu item states automatically (default: true)", 
                    type: "Input Property", 
                    desc: "When set to true (default), any menu item selected which has 'disableOnSelect' property set to true, will become disabled when selected, and will become re-enabled when any other menu item is selected. When 'ManageItemStates' is set to false, the 'disableOnSelect' menu item property is ignored"
                }, 
                {
                    name: "ItemState", 
                    externalUse: "can be used to manually enable/disable menu items (when [pbMenu].ManageItemStates is false)", 
                    type: "Component Action", 
                    desc: "Used internally by pbMenu to enable/disable a menu item.  Can be called externally to enable/disable a menu item at any time.  Note:  When 'ManageItemStates' is set to true, pbMenu will allways re-enable all menu items when any menu item is selected."
                }, 
                {
                    name: "ItemState_UpdateAll", 
                    type: "Component Action", 
                    desc: "Used internally to re-enable all menu items.  Can be called externally to enable or disable all menu items.  Please remember that when 'ManageItemStates' is set to true, all menu items are enabled any time a menu item is selected.", 
                    canCall: true 
                }, 
                {
                    name: "MenuColorPalette", 
                    valColor: Self.MenuColorPalette, 
                    dataType: "Color", 
                    type: "Input Property", 
                    desc: "Color pallete used for menu items.  Defaults to 'PowerAppsTheme.Colors.Primary'", 
                    canSet: true 
                }, 
                {
                    name: "MenuData_All", 
                    valTable: Self.MenuData_All, 
                    dataType: "Table", 
                    type: "Output Property", 
                    desc: "Unfiltered records from col_pbMenu. This Table/collection contains configuration records for all menu items in all defined menus"
                }, 
                {
                    name: "IsBusy", 
                    valBoolean: Self.IsBusy, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
                {
                    name: "IsBusyEnabled", 
                    valBoolean: Self.IsBusyEnabled, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
            
                {
                    name: "BusyMessage", 
                    valText: Self.BusyMessage, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "The message that is displayed in the pbMenu container, when pbMenu.IsBusy=true, and pbMenu.BusyBehavior='Spinner'."
                }, 
                {
                    name: "BusyBehavior", 
                    valText: Self.BusyBehavior, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Text value to indicate pbMenu behavior when pbMenu.IsBusy=true.  A helper property (pbMenu.BusyBehaviorChoices) can be use to set this property.  Valid value are either 'BusyBehaviorChoices.Spinning' ('Spinning'), or 'BusyBehaviorChoices.Disabled' ('Disabled').  When this property is missing or contains an invalid value, the default value ('Spinning') will be used."
                }, 
                {
                    name: "BusyBehaviorChoices", 
                    valRecord: Self.BusyBehaviorChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which contains valid choices for the pbMenu.BusyBehavior input property"
                }, 
                {
                    name: "ToolbarPadding", 
                    valText: Self.ToolbarPadding, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Toolbar padding is managed automatically ('Medium' for Horizontal Layout, 'Small' for Vertical Layout.)  If adjustment is necessary, can be overridden ('Small', 'Medium', 'Large').  A helper property exists to select choices (ToolbarPaddingChoices).  For example, if the name of your on-screen pbMenu component was 'myMenu' and you wanted to force 'Large' padding, you would set the 'ToolbarPadding' property to: myMenu.ToolbarPaddingChoices.Large"
                }, 
                {
                    name: "ToolbarPaddingChoices", 
                    valRecord: Self.ToolbarPaddingChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which provides valid 'ToolbarPadding' choices"
                }
            
            ]
        IsBusy: =spin.waiting=true
        ItemState: |
            =With({Perf: {id: GUID(), start: Now(), action: $"ITEM STATE CHANGE: {pbMenu.MenuKey}.{p_itemKey} (enabled: {p_enabled})"}}, 
                If(Not(StartsWith(Lower(p_itemKey),"_spacer_")) || Not(p_enabled), 
                    UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey) && Upper(ItemKey)=Upper(p_itemKey),{ItemDisabled:Not(p_enabled)})        
                );
            
            //    RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="disable" && Upper(itemKey)=Upper(p_itemKey));
            //    With({isSpacer:StartsWith(Lower(p_itemKey),"_spacer_")}, 
            //        With({tmpMenuItem: pbMenu.MenuItem(pbMenu.MenuKey,p_itemKey), shouldDisable: If(isSpacer, true, Not(p_enabled))}, 
            //            If(p_enabled=false, 
            //                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: p_itemKey, action: "disable", boolValue: true,  desc: ""});
            //            );
            //            If(tmpMenuItem.ItemDisabled<>shouldDisable, 
            //                Patch(col_pbMenu,tmpMenuItem,{ItemDisabled:shouldDisable})
            //            )
            //        )
            //    );
                If(pbMenu.PerformanceLogging=true && p_enablePerfLog=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
        ItemState_UpdateAll: |
            =With({Perf: {id: GUID(), start: Now(), action: $"UPDATE ITEM STATES (ALL): {pbMenu.MenuKey} (Enabled: {p_Enabled})"}}, 
                UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey),{ItemDisabled:Not(p_Enabled)});
            
            //    ForAll(pbMenu.MenuItems As mItem, 
            //        pbMenu.ItemState(mItem.ItemKey,p_Enabled,false)
            //    );
            
            //    pbMenu.Reset();
            //    If(pbMenu.PerformanceLogging=true, 
            //        With({endTS: Now()}, 
            //            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
            //        )
            //    )
            )
        MenuColorPalette: =RGBA(45, 128, 40, 1)
        MenuItem: =LookUp(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_itemKey))
        MenuKey: =vert2Menu
        MinimumHeight: =If(Upper(Self.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Horizontal),If(Self.OverrideMinHeight>0,Self.OverrideMinHeight, 50),140) 
        MinimumWidth: |
            =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal,200,
                If(pbMenu.CollapsedMode()=true,50,
                    If(pbMenu.OverrideExpandedWidth<=0,
                        120, 
                        pbMenu.OverrideExpandedWidth
                    )
                )
            )
        OnBeforeAction: |
            =With({handled: 
                Switch(Upper(p_itemKey), 
                    Upper("useMenu_mainVert1"), UpdateContext({vert2Menu:"mainVert1"}); Self.ItemState_UpdateAll(true); true, 
                    Upper("useMenu_mainVert2"), UpdateContext({vert2Menu:"mainVert2"}); Self.ItemState_UpdateAll(true); true, 
                    false
                )},
                If(Not(handled), 
                    Notify($"Normally, this menu item ({Self.MenuKey}.{p_itemKey}) would be wired up to something!",NotificationType.Information,2000)
                );
                //add false here to route request back to pbMenu action handler
                true 
            )
            
                    
        OnRemoveMenuItem: =
        OverrideExpandedWidth: =150
        PerformanceLogging: =pbMenu_LogPerformance
        RemoveMenuItem: |-
            =RemoveIf(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_menuItemKey));
            Self.OnRemoveMenuItem(p_menuKey,p_menuItemKey)
        Reset: =Reset(pbMenu_Vert_1)
        ToolbarOrientation: =pbMenu_Vert_1.LayoutChoices.Vertical
        Width: =Self.MinimumWidth()
        X: =pbMenu_Vert.X + pbMenu_Vert.Width
        Y: =MM.Y + MM.Height + 10 
        ZIndex: =4

    Container1 As groupContainer.manualLayoutContainer:
        BorderColor: =PowerAppsTheme.Colors.Lighter20 
        BorderThickness: =2
        DropShadow: =DropShadow.Light
        Fill: =PowerAppsTheme.Colors.Lighter80
        Height: =Parent.Height - Self.Y - 10 
        RadiusBottomLeft: =4
        RadiusBottomRight: =4
        RadiusTopLeft: =4
        RadiusTopRight: =4
        Width: =Parent.Width - Self.X - 10 
        X: =pbMenu_Vert_1.X + pbMenu_Vert_1.Width + 10
        Y: =cont_BuildUtil.Y + cont_BuildUtil.Height + 10 
        ZIndex: =5

        txtEasyStartLabel As Text:
            AutoHeight: =true
            DisplayMode: =DisplayMode.Edit
            Height: =32
            Text: ="STEPS TO QUICKLY GET GOING WITH pbMenu"
            Weight: ='TextCanvas.Weight'.Bold
            Width: =Parent.Width - Self.X * 2 
            X: =10
            Y: =10
            ZIndex: =1

        btnEasyStart As Button:
            DisplayMode: =DisplayMode.Edit
            Height: =80
            OnSelect: =Navigate('Get Started',ScreenTransition.Fade)
            Text: ="CLICK FOR MINIMUM STEP-BY-STEP INSTRUCTIONS TO START USING THE pbMenu COMPONENT"
            Width: =400
            X: =10
            Y: =40
            ZIndex: =2

    cont_BuildUtil As groupContainer.manualLayoutContainer:
        BorderColor: =PowerAppsTheme.Colors.Lighter20 
        BorderThickness: =2
        DropShadow: =DropShadow.Light
        Fill: =PowerAppsTheme.Colors.PrimaryForeground
        Height: =300
        RadiusBottomLeft: =4
        RadiusBottomRight: =4
        RadiusTopLeft: =4
        RadiusTopRight: =4
        Width: =Parent.Width - Self.X - 10 
        X: =pbMenu_Vert_1.X + pbMenu_Vert_1.Width + 10
        Y: |-
            =MM.Y + MM.Height + 10 +100
            //Container1.Y + Container1.Height + 10 
        ZIndex: =8

        txtInteractiveBuildTitle As Text:
            AutoHeight: =true
            DisplayMode: =DisplayMode.Edit
            Height: =32
            Text: ="Interactive Build Menu Demo" 
            Weight: ='TextCanvas.Weight'.Bold
            Width: =Parent.Width - Self.X * 2 
            X: =10
            Y: =10
            ZIndex: =1

        txtInteractiveBuildInfo As Text:
            AutoHeight: =true
            DisplayMode: =DisplayMode.Edit
            Height: =Parent.Height - Self.Y - 10 
            Size: =14
            Text: |-
                ="Click the 'MENU BUILDER' menu item to build and interact with the pbMenu" & const_CrLf & const_CrLf & 
                "*** Choose and switch between Horizontal, Vertical Fixed Width, and Vertical Collapsible layouts" & const_CrLf & 
                "*** Use custom color palette to select toolbar button colors" & const_CrLf & 
                "*** Build menu items, add optional spacers" & const_CrLf & 
                "*** Create menu items that disable automatically when selected (or manage menu item states manually" & const_CrLf & 
                "*** Create menu items that require user confirmation after initial selection" & const_CrLf & 
                "*** Choose behavior of menu when application is busy" & const_CrLf & 
                "*** Instantly change available menu items" & const_CrLf & 
                "*** View all information about a menu, including filterable pbMenu properties, functions, actions, and events" & const_CrLf & 
                "*** Build JSON for adding menu items at run-time"
            Weight: ='TextCanvas.Weight'.Semibold
            Width: =Parent.Width - Self.X * 2 
            X: =txtInteractiveBuildTitle.X 
            Y: =txtInteractiveBuildTitle.Y + txtInteractiveBuildTitle.Height + 10 
            ZIndex: =2

    btnDemoIsNotBusy As Button:
        BasePaletteColor: =PowerAppsTheme.Colors.Lighter60
        BorderColor: =RGBA(224, 86, 6, 1)
        BorderStyle: =BorderStyle.Solid
        BorderThickness: =1
        DisplayMode: =DisplayMode.Edit
        FontWeight: =FontWeight.Bold
        Height: =32
        OnSelect: =Set(spin,Blank());
        Text: ="Is Not Busy"
        Width: =126
        X: =btnDemoDisableAll.X + btnDemoDisableAll.Width + 2 
        Y: =btnDemoIsBusy.Y + btnDemoIsBusy.Height + 2 
        ZIndex: =10

    btnDemoIsBusy As Button:
        BasePaletteColor: =PowerAppsTheme.Colors.Lighter60
        BorderColor: =RGBA(224, 86, 6, 1)
        BorderStyle: =BorderStyle.Solid
        BorderThickness: =1
        DisplayMode: =DisplayMode.Edit
        FontWeight: =FontWeight.Bold
        Height: =32
        OnSelect: |+
            =Set(spin,{waiting: true,msg: $"Busy, please wait: {Text(Now(),"hh:mm:ss am/pm")}"});
            
        Text: ="Is Busy"
        Width: =126
        X: =btnDemoEnableAll.X + btnDemoEnableAll.Width + 2 
        Y: =MM.Y + MM.Height + 10
        ZIndex: =11

    btnDemoDisableAll As Button:
        BasePaletteColor: =PowerAppsTheme.Colors.Lighter60
        BorderColor: =RGBA(224, 86, 6, 1)
        BorderStyle: =BorderStyle.Solid
        BorderThickness: =1
        DisplayMode: =DisplayMode.Edit
        FontWeight: =FontWeight.Bold
        Height: =32
        OnSelect: =MM.ItemState_UpdateAll(false)
        Text: ="disable all"
        Width: =126
        X: =pbMenu_Vert_1.X + pbMenu_Vert_1.Width + 10
        Y: =btnDemoEnableAll.Y + btnDemoEnableAll.Height + 2 
        ZIndex: =12

    btnDemoEnableAll As Button:
        BasePaletteColor: =PowerAppsTheme.Colors.Lighter60
        BorderColor: =RGBA(224, 86, 6, 1)
        BorderStyle: =BorderStyle.Solid
        BorderThickness: =1
        DisplayMode: =DisplayMode.Edit
        FontWeight: =FontWeight.Bold
        Height: =32
        OnSelect: =MM.ItemState_UpdateAll(true)
        Text: ="enable all"
        Width: =126
        X: =pbMenu_Vert_1.X + pbMenu_Vert_1.Width + 10
        Y: =MM.Y + MM.Height + 10
        ZIndex: =13

    dData As pbMenuData:
        BuildDemoMenus: |-
            =Set(spin,{waiting: true,msg: "Please wait ..."});
            
            //Clear(col_pbMenu);
            Clear(col_pbMenuUtil);
            
            MM.CreateMenuItem("Main","miNavBuild","MENU BUILDER","ArrowRight",MM.ItemAppearanceChoices.Primary,MM.ItemIconStyleChoices.Filled,"Build a Menu",false,false,true);
            MM.CreateMenuItem("Main","miNavPerf","PERF LOG","ArrowRight",MM.ItemAppearanceChoices.Primary,MM.ItemIconStyleChoices.Filled,"View Performance Log",false,false,true);
            MM.CreateSpacer("Main",true);
            MM.CreateMenuItem("Main","launchGithub","lopperman @ github","Open",MM.ItemAppearanceChoices.Outline,MM.ItemIconStyleChoices.Filled,"Paul Brower Github Profile",false,false,true);
            MM.CreateMenuItem("Main","launchReddit","ITFuture @ reddit","Open",MM.ItemAppearanceChoices.Outline,MM.ItemIconStyleChoices.Filled,"Paul Brower Reddit Profile",false,false,true);
            MM.CreateMenuItem("Main","TogglePerfLogging","Toggle Perf Logging","ServiceBell",MM.ItemAppearanceChoices.Outline,MM.ItemIconStyleChoices.Filled,"",false,false,true);
            
            MM.CreateInfoItem("mainVert1","Menu: MainVert1",MM.ItemAppearanceChoices.Outline,"Menu Name",true);
            MM.CreateMenuItem("mainVert1","launchGithub","lopperman @ github","Open",MM.ItemAppearanceChoices.Outline,MM.ItemIconStyleChoices.Filled,"Paul Brower Github Profile",true,false,true);
            MM.CreateMenuItem("mainVert1","launchReddit","ITFuture @ reddit","Open",MM.ItemAppearanceChoices.Outline,MM.ItemIconStyleChoices.Filled,"Paul Brower Reddit Profile",true,false,true);
            MM.CreateSpacer("mainVert1",true);
            MM.CreateMenuItem("mainVert1","useMenu_mainVert2","Use Menu V2","People",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Demo",false,true,true);
            MM.CreateSpacer("mainVert1",true);
            MM.CreateMenuItem("mainVert1","disableOtherMenus","Disable Menus","DismissCircle",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Disable Other Menus",true,false,true);
            MM.CreateMenuItem("mainVert1","enableOtherMenus","Enable Menus","CheckmarkCircle",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Enable Other Menus",true,false,true);
            
            MM.CreateInfoItem("mainVert2","Menu: MainVert2",MM.ItemAppearanceChoices.Outline,"Menu Name",true);
            MM.CreateMenuItem("mainVert2","miNavBuild","MENU BUILDER","ArrowRight",MM.ItemAppearanceChoices.Primary,MM.ItemIconStyleChoices.Filled,"Build a Menu",false,false,true);
            MM.CreateMenuItem("mainVert2","launchGithub","lopperman @ github","Open",MM.ItemAppearanceChoices.Outline,MM.ItemIconStyleChoices.Filled,"Paul Brower Github Profile",true,false,true);
            MM.CreateMenuItem("mainVert2","launchReddit","ITFuture @ reddit","Open",MM.ItemAppearanceChoices.Outline,MM.ItemIconStyleChoices.Filled,"Paul Brower Reddit Profile",true,false,true);
            MM.CreateSpacer("mainVert2",true);
            MM.CreateMenuItem("mainVert2","useMenu_mainVert1","Use Menu V1","Person",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Demo",true,true,true);
            
            
            MM.CreateMenuItem("MenuBuilder","mbBuild","BUILD","Settings",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Create Menu Items",true,false,true);
            MM.CreateMenuItem("MenuBuilder","mbViewData","VIEW MENU INFO","Eye",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"View Menu Data",true,false,true);
            MM.CreateSpacer("menuBuilder",true);
            MM.CreateMenuItem("MenuBuilder","mbExampleMenu","CREATE EXAMPLE MENU","Add",MM.ItemAppearanceChoices.Transparent, MM.ItemIconStyleChoices.Filled,"Create Example Menu",false,true,true);
            MM.CreateMenuItem("MenuBuilder","mbExampleMenuAbout","ABOUT EXAMPLE MENU","Question",MM.ItemAppearanceChoices.Transparent, MM.ItemIconStyleChoices.Filled,"Create Example Menu",true,false,true);
            MM.CreateSpacer("menuBuilder",true);
            MM.CreateMenuItem("MenuBuilder","mbReset","RESET","DismissCircle",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Clear Demo Menu Items",false,true,true);
            MM.CreateMenuItem("menuBuilder","miNavPerf","PERF LOG","ArrowRight",MM.ItemAppearanceChoices.Primary,MM.ItemIconStyleChoices.Filled,"View Performance Log",false,false,true);
            
            
            MM.CreateMenuItem("mbHelper_View","mbhJSON","MENU JSON","Eye",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"View Menu JSON",false,false,true);
            MM.CreateMenuItem("mbHelper_View","mbhMenuProps","MENU INFO","Info",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"View Menu Properties",false,false,true);
            MM.CreateMenuItem("mbHelper_View","mbhInputProps","INPUT PROPERTIES","Edit",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"View Input Properties",false,false,true);
            MM.CreateMenuItem("mbHelper_View","mbhOutputProps","OUTPUT PROPERTIES","Eye",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"View Output Properties",false,false,true);
            MM.CreateMenuItem("mbHelper_View","mbhOutputFunctions","OUTPUT FUNCTIONS","Eye",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"View Output Functions",false,false,true);
            MM.CreateMenuItem("mbHelper_View","mbhMenuItems","CURRENT MENU ITEMS","List",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"View Current Menu Items",false,false,true);
            MM.CreateMenuItem("mbHelper_View","mbhActions","COMPONENT ACTIONS","List",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"View Component Actions",false,false,true);
            
            //MM.CreateMenuItem("mbHelper_Build","mbbCreate","New Item","Add",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Create Menu Item",true,false,true);
            MM.CreateInfoItem("mbHelper_Build","MENU ITEMS",MM.ItemAppearanceChoices.Transparent,"",true);
            MM.CreateSpacer("mbHelper_Build",true);
            MM.CreateMenuItem("mbHelper_Build","mbbSave","Create Item","Save",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Save Menu Item",false,true,true);
            MM.CreateMenuItem("mbHelper_Build","mbbCreateSpacer","New Spacer","Circle",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Create Menu Item Spacer",false,false,true);
            MM.CreateMenuItem("mbHelper_Build","mbbDelete","Remove Item","Delete",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Delete Menu Item",false,true,true);
            //MM.CreateMenuItem("mbHelper_Build","mbbUndo","Revert Item","ArrowUndo",MM.ItemAppearanceChoices.Primary, MM.ItemIconStyleChoices.Filled,"Undo Menu Item",false,true,true);
            MM.CreateSpacer("mbHelper_Build",true);
            MM.CreateInfoItem("mbHelper_Build","AIN'T THIS COOL?",MM.ItemAppearanceChoices.Transparent,"",true);
            
            
            MM.CreateMenuItem("pbMenuPerfLog","sortStartToggle","Sort Start Desc","ArrowSort",MM.ItemAppearanceChoices.Outline, MM.ItemIconStyleChoices.Filled,"Sort by Start ",false,false,true);
            MM.CreateMenuItem("pbMenuPerfLog","sortElapsedToggle","Sort Elapsed Desc","ArrowSort",MM.ItemAppearanceChoices.Outline, MM.ItemIconStyleChoices.Filled,"Sort by Elapsed",false,false,true);
            
            
            Set(spin,Blank());
        Height: =105
        MenuItems: |-
            =With({fItems: Filter(col_pbMenu,Upper(menuKey)=Upper(p_menuKey))}, 
                ShowColumns(fItems,ItemKey,ItemDisplayName,ItemIconName, ItemAppearance, ItemIconStyle, ItemTooltip, ItemDisabled)
            )
        Width: =310
        X: =Parent.Width - Self.Width - 8
        Y: =MM.Y + MM.Height
        ZIndex: =14

    btnDemoRebuildMenus As Button:
        BasePaletteColor: =PowerAppsTheme.Colors.Lighter60
        BorderColor: =RGBA(224, 86, 6, 1)
        BorderStyle: =BorderStyle.Solid
        BorderThickness: =1
        DisplayMode: =DisplayMode.Edit
        FontWeight: =FontWeight.Bold
        Height: =66
        Icon: ="GlobeError"
        OnSelect: |
            =Clear(col_pbMenu);
            Clear(col_pbMenuUtil);
            dData.BuildDemoMenus();
        Text: ="REBUILD MENUS"
        Width: =126
        X: =btnDemoIsBusy.X + btnDemoIsBusy.Width + 20
        Y: =MM.Y + MM.Height + 10
        ZIndex: =15

    githubProfile As image:
        BorderColor: =RGBA(0, 0, 0, 0)
        BorderThickness: =2
        DisabledBorderColor: =RGBA(0, 0, 0, 0)
        DisabledFill: =RGBA(0, 0, 0, 0)
        FocusedBorderThickness: =4
        Height: =64
        HoverBorderColor: =RGBA(0, 46, 255, 1)
        HoverFill: =RGBA(180, 214, 250, 1)
        Image: =github
        ImagePosition: =ImagePosition.Stretch
        OnSelect: =MM.DoMenu(MM.MenuKey,"launchgithub")
        PressedBorderColor: =RGBA(0, 0, 0, 0)
        PressedFill: =RGBA(0, 0, 0, 0)
        Tooltip: ="lopperman @ github"
        Width: =50
        X: =btnDemoRebuildMenus.X + btnDemoRebuildMenus.Width + 20
        Y: =102
        ZIndex: =16

    redditProfile As image:
        BorderColor: =RGBA(0, 0, 0, 0)
        BorderThickness: =2
        DisabledBorderColor: =RGBA(0, 0, 0, 0)
        DisabledFill: =RGBA(0, 0, 0, 0)
        FocusedBorderThickness: =4
        Height: =64
        HoverBorderColor: =RGBA(0, 46, 255, 1)
        HoverFill: =RGBA(180, 214, 250, 1)
        Image: =reddit
        OnSelect: =MM.DoMenu(MM.MenuKey,"launchreddit")
        PressedBorderColor: =RGBA(0, 0, 0, 0)
        PressedFill: =RGBA(0, 0, 0, 0)
        Tooltip: ="ITFuture @ reddit"
        Width: =50
        X: =githubProfile.X + githubProfile.Width + 20 
        Y: =102
        ZIndex: =17

    btnDemoIsNotBusy_1 As Button:
        BasePaletteColor: =PowerAppsTheme.Colors.Lighter60
        BorderColor: =RGBA(224, 86, 6, 1)
        BorderStyle: =BorderStyle.Solid
        BorderThickness: =1
        DisplayMode: =DisplayMode.Edit
        FontWeight: =FontWeight.Bold
        Height: =btnDemoRebuildMenus.Height
        OnSelect: =MM.DoMenu(MM.MenuKey,"google")
        Text: ="Use non-existing menu item ('google')" 
        Width: =160
        X: =redditProfile.X + redditProfile.Width + 20 
        Y: =btnDemoRebuildMenus.Y 
        ZIndex: =18

    TextCanvas5 As Text:
        AutoHeight: =true
        DisplayMode: =DisplayMode.Edit
        FontColor: =clr_BLUEBERRY
        Height: =32
        Text: |-
            =$"'pbMenu_LogPerformance' global variable set to: {pbMenu_LogPerformance}"
        VerticalAlign: =VerticalAlign.Middle
        Width: =400
        X: =pbMenu_Vert_1.X + pbMenu_Vert_1.Width + 10
        Y: =173
        ZIndex: =19

