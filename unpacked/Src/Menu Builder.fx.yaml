"'Menu Builder' As screen":
    LoadingSpinnerColor: =RGBA(0, 120, 212, 1)
    OnVisible: |
        =If(CountIf(col_pbMenu,true)=0,dData.BuildDemoMenus());
        pbMenu_MenuBuilder.DoMenu(pbMenu_MenuBuilder.MenuKey,"mbBuild");
        
        UpdateContext({miPrimaryColorPalette:PowerAppsTheme.Colors.Primary});
        UpdateContext({confirmColorPalette:Color.Red});
        UpdateContext({cancelColorPalette:clr_YELLOWSELECTED});
        UpdateContext({ignoreUnhandled:true}); Reset(toggIgnoreUnhandled);
        UpdateContext({manageItemStates:true}); Reset(toggManageItemStates);
        UpdateContext({enableCollapse:true}); Reset(toggEnableCollapsedState);
        UpdateContext({enableIsBusyResponse: true}); Reset(toggIsBusyEnabled);
        UpdateContext({showAboutExMenu: false});
        UpdateContext({ownR:Blank()}); Reset(txtOwnR);
        UpdateContext({ownG:Blank()}); Reset(txtOwnG);
        UpdateContext({ownB:Blank()}); Reset(txtOwnB);
        UpdateContext({ownA:1}); Reset(txtOwnA);
        UpdateContext({infoSearch: ""});
        
        UpdateContext({helperView: "menuProps"});
        
        If(IsBlankOrError(currentDisplayedMenu), 
            UpdateContext({currentDisplayedMenu: "exampleMenu"})
        )

    Header1_1 As Header:
        DisplayMode: =DisplayMode.Edit
        Height: =40
        Logo: =stickeromglove
        OnSelectLogo: =false
        Title: =App.ActiveScreen.Name
        TitleRole: =""
        UserEmail: =User().Email
        UserImage: =User().Image
        UserImageAltText: =User().FullName &" profile picture"
        UserName: =User().FullName
        Width: =Parent.Width
        X: =0
        Y: =0
        ZIndex: =1

    pbMenu_MenuBuilder As pbMenu:
        Collapse: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            If(Self.EnableUserCollapse=false, 
                                false, 
                                pbMenu_MenuBuilder.DefaultCollapsedState
                            )
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=false, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu_MenuBuilder.ControlGUID), menuKey: pbMenu_MenuBuilder.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: true,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:true})
                            )
                        )
                    )
            
                )    
            )
        CollapsedMode: |-
            =//If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal || Self.EnableCollapsedState<>true, false,     
            If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal, false,     
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    If(IsBlank(collapseRec), 
                        pbMenu_MenuBuilder.DefaultCollapsedState
                        , 
                        collapseRec.boolValue
                    )       
                )
            )
        ConfirmAction: |+
            =With({Perf: {id: GUID(), start: Now(), action: $"CONFIRM ACTION: {p_menuKey}.{p_itemKey} ({p_itemDisplay})"}}, 
                RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm");
                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: p_menuKey,itemKey: p_itemKey, action: "confirm", boolValue: true,  desc: p_itemDisplay});
                If(pbMenu.PerformanceLogging=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
            
        ConfirmationColorPalette: =RGBA(160, 64, 8, 1)
        ConfirmMode: =CountIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")>0
        CreateInfoItem: |
            =With({newMenuItem: 
                //get menu item structure
                {
                    menuKey: Upper(TrimEnds(p_menuKey)), 
                    ItemKey: Upper($"_info_{GUID()}"), 
                    ItemDisplayName: TrimEnds(p_itemDisplay), 
                    ItemIconName: "Info", 
                    ItemAppearance: TrimEnds(p_itemAppearance), 
                    ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
                    ItemTooltip: TrimEnds(p_itemTooltip), 
                    ItemDisabled: false, 
                    disableOnSelect: false, 
                    confirmItemAction: false
                }}
                , 
                If(p_addToCollection=true, 
                    RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                    Collect(col_pbMenu,newMenuItem)
                );
                newMenuItem 
            )
        CreateMenuItem: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE MENU ITEM: {p_menuKey}.{p_ItemKey} ({p_ItemDisplayName})"}}, 
                With({isSpacer: (Len(TrimEnds(p_ItemKey))=0)=true},     
                    With({newMenuItem: 
                        If(isSpacer, 
                            //get spacer structure (without adding -- can be added to collection below if appropriate)
                            Self.CreateSpacer(p_menuKey,false), 
                            //get menu item structure
                            {menuKey: Upper(TrimEnds(p_menuKey)), ItemKey: Upper(TrimEnds(Coalesce(p_ItemKey,$"_spacer_{GUID()}"))), ItemDisplayName: If(isSpacer,"",TrimEnds(p_ItemDisplayName)), ItemIconName: If(isSpacer," ", TrimEnds(p_ItemIconName)), ItemAppearance: TrimEnds(p_ItemAppearance), ItemIconStyle: TrimEnds(p_ItemIconStyle), ItemTooltip: TrimEnds(p_ItemTooltip), ItemDisabled: isSpacer, disableOnSelect: p_disableOnSelect, confirmItemAction: p_confirmItemAction}
                        )}, 
                        If(p_addToCollection=true, 
                            RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                            Collect(col_pbMenu,newMenuItem)
                        );
                        If(pbMenu.PerformanceLogging=true, 
                            With({endTS: Now()}, 
                                Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                            )
                        );
                        newMenuItem 
                    )
                )
            )
        CreateSpacer: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE SPACER: {p_menuKey} (Add to collection: {p_addToCollection})"}}, 
                With({newSpacer: 
                    If(Len(TrimEnds(p_menuKey))=0, 
                        Blank(), 
                        {
                            menuKey: Upper(TrimEnds(p_menuKey)), 
                            ItemKey: $"_spacer_{GUID()}", 
                            ItemDisplayName: " ", 
                            ItemIconName: "", 
                            ItemAppearance: Self.ItemAppearanceChoices.Transparent,  
                            ItemIconStyle: Self.ItemIconStyleChoices.Outline, 
                            ItemTooltip: "", 
                            ItemDisabled: true, 
                            disableOnSelect: false, 
                            confirmItemAction: false    
                        }
                    )}, 
                    If(p_addToCollection=true && Not(IsBlank(newSpacer)), 
                        Collect(col_pbMenu,newSpacer)
                    );
                    If(pbMenu.PerformanceLogging=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    );
                    newSpacer
                )
            )
        DoMenu: |-
            =With({spinning: spin.waiting=true, spinningMsg: spin.msg}, 
                If(Not(spinning), Set(spin, {waiting: true, msg: "Please wait ..."}));
                With({mi: pbMenu.MenuItem(p_menuKey,p_itemKey)}, 
                    If(mi.confirmItemAction=true, 
                        If(Self.ConfirmMode() <> true, 
                            //Add 'confirm' action and waits for user to confirm or cancel
                            //cancel clears confirm action
                            //confirm calls DoMenu again, which can then move forward
                            Self.ConfirmAction(p_menuKey,p_itemKey,mi.ItemDisplayName)
                            , 
                            //clear the 'confirm' action, which is now confirmed, and 
                            //process menuItem as normal
                            RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")
                        )
                    );
                    With({doMenuHandled: 
                        If(Self.ConfirmMode() <> true, 
                            If(pbMenu.ManageItemStates = true, 
                                pbMenu.ItemState_UpdateAll(true);
                                If(mi.disableOnSelect=true, 
                                    pbMenu.ItemState(mi.ItemKey,false)
                                )
                            );
                            //Raise 'OnBeforeAction'.  If handled in event on screen ('true' returned), no further action is taken.
                            //If not handled in the 'OnBeforeAction', will attempt to handle below and show error if was not handled.
                            If(Self.OnBeforeAction(p_itemKey) = true, 
                                true
                                , 
                                With({handledHere: 
                                    Switch(Upper(p_itemKey), 
                                        "LAUNCHGITHUB", Launch("https://github.com/lopperman"); true, 
                                        "LAUNCHREDDIT", Launch("https://www.reddit.com/user/ITFuture"); true, 
                                        "GOOGLE", Launch("https://www.google.com"); true, 
                                        "MINAVPERF", Navigate(PerformanceLog,ScreenTransition.Fade); true, 
            
                                        //not handled
                                        Notify("NO ACTION WAS TAKEN FOR MENU ITEM: " & p_menuKey & "." & p_itemKey & " (" & mi.ItemDisplayName & ")",NotificationType.Error,5000);
                                        false
                                    )}, 
                                    handledHere
                                )
                            );
                        )
                        }, 
                        If(Not(spinning), Set(spin,{waiting: false,msg:"Please wait ..."}));
                        doMenuHandled
                    )
            
                );
            )
        Expand: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            pbMenu_MenuBuilder.DefaultCollapsedState
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=true, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu_MenuBuilder.ControlGUID), menuKey: pbMenu_MenuBuilder.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: false,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:false})
                            )
                        )
                    )
                )    
            )
        Height: =Self.MinimumHeight()
        Information: |-
            =[
                {
                    name: "About", 
                    type: "General pbMenu Help",
                    desc: "** NOTE: '[pbMenu]' is referenced in this documentation in relation to getting/setting/calling actions for a pbMenu component. Please remember that 'pbMenu' can never be referenced directly from a screen, and should be replaced with the name of the pbMenu component on your screen.  For example, if you added a pbMenu component to your screen, and named it 'mainMenu1', that all interactions for that menu would use 'mainMenu1', and not 'pbMenu'"        
                },
                {
                    name: "ToolbarOrientation", 
                    valText: Self.ToolbarOrientation, 
                    dataType: "Text", 
                    externalUse: "[pbMenu].LayoutChoices.Horizontal (default), or [pbMenu].LayoutChoices.Vertical", 
                    type: "Input Property",
                    desc: "Use to get or set the orientation of [pbMenu]"
                },
                {
                    name: "MinimumHeight()", 
                    valNumber: Self.MinimumHeight(), 
                    dataType: "Number", 
                    externalUse: "When in 'Horizontal' layout mode, set the pbMenu component (added to your screen) 'Height' property to be 'Self.MinimumHeight()'", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Height, when in Horizontal layout mode.  Note: Property 'OverrideMinHeight can be used to fine tune desired menu height."
                },
                {
                    name: "MinimumWidth()", 
                    valNumber: Self.MinimumWidth(), 
                    dataType: "Number", 
                    externalUse: "When in 'Vertical' layout mode, set the pbMenu component (added to your screen) 'Width' property to be 'Self.MinimumWidth()'.  This will enable the pbMenu control to automatically resize when user collapses or expands the menu.", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Width, when in Vertical layout mode,  Note: if you need to adjust the expanded width, use the 'OverrideExpandedWidth' property to set the desired expanded width value"
                },
                {
                    name: "CurrentMenuItems", 
                    valTable: Self.CurrentMenuItems, 
                    dataType: "Table", 
                    externalUse: "Reference Only", 
                    type: "Output Property",
                    desc: "Current Menu Items.   Retrieved by filtering items from 'MenuData' datasource, where menuName=[pbMenu].MenuKey"
                },
                {
                    name: "CancelMenuColorPalette", 
                    valColor: Self.CancelMenuColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Cancel' button; Default is RGBA(0,0,0,0)", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Cancel' button for required user confirmation"
                },
                {
                    name: "CollapseMode()", 
                    valBoolean: Self.CollapsedMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function",
                    desc: "Returns true when 'ToolbarOrientation' is Vertical and menu is collapsed"
                },
                {
                    name: "DefaultCollapsedState", 
                    valBoolean: Self.DefaultCollapsedState, 
                    dataType: "Boolean", 
                    externalUse: "Use to set default collapsed state (true=collapsed, false=expanded)", 
                    type: "Input Property", 
                    desc: "When true, default state of menu will be collapsed, when menu is configured for vertical layout"
                }, 
                {
                    name: "EnableUserCollapse", 
                    valBoolean: Self.EnableUserCollapse, 
                    dataType: "Boolean", 
                    externalUse: "Set to 'false' to prevent vertical menu from ever displaying in collapsed/icon-only mode", 
                    type: "Input Property", 
                    desc: "Defaults to true; controls whether vertical menu can be collapsed"
                }, 
                {
                    name: "ConfirmationColorPalette", 
                    valColor: Self.ConfirmationColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Confirm' button", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Confirm' button for required user confirmation"
                }, 
                {
                    name: "ConfirmMode()", 
                    valBoolean: Self.ConfirmMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function", 
                    desc: "When user has selected a menu item which requires confirmation, [pbMenu].'ConfirmMode()' will return true until user has selected 'Confirm' or 'Cancel'"
                }, 
                {   
                    name: "ControlGUID", 
                    valText: Self.ControlGUID, 
                    dataType: "Text", 
                    externalUse: "Reference Only.  VALUE WILL CHANGE BETWEEN SESSIONS!", 
                    type: "Output Property", 
                    desc: "Unique value which can be used at runtime only, and may update each time a screen becomes visible.  The purpose of this property is to manage specific state information"
                }, 
                {
                    name: "ItemAppearanceChoices", 
                    valRecord: Self.ItemAppearanceChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemAppearance' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property wich can be used when setting value for 'ItemAppearance', when creating a new menu item using [pbMenu].'Create Menu Item'()"
                }, 
                {
                    name: "ItemIconStyleChoices", 
                    valRecord: Self.ItemIconStyleChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemIconStyle' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value for 'ItemIconStyle', when creating a new menu item using [pbMenu].'Create Menu Item'"
                }, 
                {
                    name: "LayoutChoices", 
                    valRecord: Self.LayoutChoices, 
                    dataType: "Record", 
                    externalUse: "Helper used to set valid [pbMenu].ToolbarOrientation", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value of [pbMenu].ToolbarOrientation"
                }, 
                {
                    name: "ConfirmAction", 
                    dataType: "n/a", 
                    externalUse: "Optionally can be used to trigger a menu item selection confirmation (see desc)", 
                    type: "Component Action", 
                    desc: "Trigger action which requires user to confirm or cancel selected menu item.  Used internally by pbMenu when a menu item is selected that was created with 'confirmItemAction' = true. While not intended to be called externally, this action can be triggered outside the pbMenu component as long as the parameter arguments (p_menuKey, p_itemKey, p_itemDisplay) match a menu item which currently is being displayed in [pbMenu]"
                }, 
                {
                    name: "CreateMenuItem", 
                    type: "Component Action", 
                    dataType: "Record", 
                    externalUse: "Returns Menu Item Record data which is also automatically added to collection: col_pbMenu if the 'p_addToCollection' argument is true", 
                    desc: "Returns a menu item record based on provided parameter values.  By default, new menu item is not added to a data source and therefore will not be available for use.  When called with p_addToCollection=true, the new menu item will be added to col_pbMenu (default data source for [pbMenu]), and becomes available for use by any pbMenu component.", 
                    example: $"To get the correct structure (record) of a menu item you wish to add, which will be stored in an external datasource -- like SharePoint or DataVerse -- the following would return that record and NOT add it to the default MenuData datasource ('col_pbMenu'):  [pbMenu].CreateMenuItem({Char(34)}Main{Char(34)},{Char(34)}miNavBuild{Char(34)},{Char(34)}MENU BUILDER{Char(34)},{Char(34)}ArrowRight{Char(34)},[pbMenu].ItemAppearanceChoices.Primary,[pbMenu].ItemIconStyleChoices.Filled,{Char(34)}Build a Menu{Char(34)},false,false,false);, setting the last parameter to 'true' would cause the new menu item to also be added to 'col_pbMenu'"
                }, 
                {
                    name: "DoMenu", 
                    externalUse: "Optionally use to trigger a menu item selection (see desc)", 
                    type: "Component Action", 
                    desc: "Called when user selects a menu item which was rendered from [pbMenu].MenuData data source. Can also be called externally. When a menu item that requires user confirmation is selected, 'DoMenu' is not called until user also selects the confirmation button. When 'DoMenu' is called externally, the item key property is NOT required to correlate to a menu item currently available, as long as the pbMenu being called is able to process the 'p_ItemKey' argument in the [pbMenu].OnBeforeAction event on the current screen."
                }, 
                {
                    name: "ManageItemStates", 
                    valBoolean: Self.ManageItemStates, 
                    dataType: "Boolean", 
                    externalUse: "Used to enable a pbMenu to change menu item states automatically (default: true)", 
                    type: "Input Property", 
                    desc: "When set to true (default), any menu item selected which has 'disableOnSelect' property set to true, will become disabled when selected, and will become re-enabled when any other menu item is selected. When 'ManageItemStates' is set to false, the 'disableOnSelect' menu item property is ignored"
                }, 
                {
                    name: "ItemState", 
                    externalUse: "can be used to manually enable/disable menu items (when [pbMenu].ManageItemStates is false)", 
                    type: "Component Action", 
                    desc: "Used internally by pbMenu to enable/disable a menu item.  Can be called externally to enable/disable a menu item at any time.  Note:  When 'ManageItemStates' is set to true, pbMenu will allways re-enable all menu items when any menu item is selected."
                }, 
                {
                    name: "ItemState_UpdateAll", 
                    type: "Component Action", 
                    desc: "Used internally to re-enable all menu items.  Can be called externally to enable or disable all menu items.  Please remember that when 'ManageItemStates' is set to true, all menu items are enabled any time a menu item is selected.", 
                    canCall: true 
                }, 
                {
                    name: "MenuColorPalette", 
                    valColor: Self.MenuColorPalette, 
                    dataType: "Color", 
                    type: "Input Property", 
                    desc: "Color pallete used for menu items.  Defaults to 'PowerAppsTheme.Colors.Primary'", 
                    canSet: true 
                }, 
                {
                    name: "MenuData_All", 
                    valTable: Self.MenuData_All, 
                    dataType: "Table", 
                    type: "Output Property", 
                    desc: "Unfiltered records from col_pbMenu. This Table/collection contains configuration records for all menu items in all defined menus"
                }, 
                {
                    name: "IsBusy", 
                    valBoolean: Self.IsBusy, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
                {
                    name: "IsBusyEnabled", 
                    valBoolean: Self.IsBusyEnabled, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
            
                {
                    name: "BusyMessage", 
                    valText: Self.BusyMessage, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "The message that is displayed in the pbMenu container, when pbMenu.IsBusy=true, and pbMenu.BusyBehavior='Spinner'."
                }, 
                {
                    name: "BusyBehavior", 
                    valText: Self.BusyBehavior, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Text value to indicate pbMenu behavior when pbMenu.IsBusy=true.  A helper property (pbMenu.BusyBehaviorChoices) can be use to set this property.  Valid value are either 'BusyBehaviorChoices.Spinning' ('Spinning'), or 'BusyBehaviorChoices.Disabled' ('Disabled').  When this property is missing or contains an invalid value, the default value ('Spinning') will be used."
                }, 
                {
                    name: "BusyBehaviorChoices", 
                    valRecord: Self.BusyBehaviorChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which contains valid choices for the pbMenu.BusyBehavior input property"
                }, 
                {
                    name: "ToolbarPadding", 
                    valText: Self.ToolbarPadding, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Toolbar padding is managed automatically ('Medium' for Horizontal Layout, 'Small' for Vertical Layout.)  If adjustment is necessary, can be overridden ('Small', 'Medium', 'Large').  A helper property exists to select choices (ToolbarPaddingChoices).  For example, if the name of your on-screen pbMenu component was 'myMenu' and you wanted to force 'Large' padding, you would set the 'ToolbarPadding' property to: myMenu.ToolbarPaddingChoices.Large"
                }, 
                {
                    name: "ToolbarPaddingChoices", 
                    valRecord: Self.ToolbarPaddingChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which provides valid 'ToolbarPadding' choices"
                }
            
            ]
        ItemState: |
            =With({Perf: {id: GUID(), start: Now(), action: $"ITEM STATE CHANGE: {pbMenu.MenuKey}.{p_itemKey} (enabled: {p_enabled})"}}, 
                If(Not(StartsWith(Lower(p_itemKey),"_spacer_")) || Not(p_enabled), 
                    UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey) && Upper(ItemKey)=Upper(p_itemKey),{ItemDisabled:Not(p_enabled)})        
                );
            
            //    RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="disable" && Upper(itemKey)=Upper(p_itemKey));
            //    With({isSpacer:StartsWith(Lower(p_itemKey),"_spacer_")}, 
            //        With({tmpMenuItem: pbMenu.MenuItem(pbMenu.MenuKey,p_itemKey), shouldDisable: If(isSpacer, true, Not(p_enabled))}, 
            //            If(p_enabled=false, 
            //                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: p_itemKey, action: "disable", boolValue: true,  desc: ""});
            //            );
            //            If(tmpMenuItem.ItemDisabled<>shouldDisable, 
            //                Patch(col_pbMenu,tmpMenuItem,{ItemDisabled:shouldDisable})
            //            )
            //        )
            //    );
                If(pbMenu.PerformanceLogging=true && p_enablePerfLog=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
        ItemState_UpdateAll: |
            =With({Perf: {id: GUID(), start: Now(), action: $"UPDATE ITEM STATES (ALL): {pbMenu.MenuKey} (Enabled: {p_Enabled})"}}, 
                UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey),{ItemDisabled:Not(p_Enabled)});
            
            //    ForAll(pbMenu.MenuItems As mItem, 
            //        pbMenu.ItemState(mItem.ItemKey,p_Enabled,false)
            //    );
            
            //    pbMenu.Reset();
            //    If(pbMenu.PerformanceLogging=true, 
            //        With({endTS: Now()}, 
            //            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
            //        )
            //    )
            )
        MenuItem: =LookUp(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_itemKey))
        MenuKey: ="MenuBuilder"
        MinimumHeight: =If(Upper(Self.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Horizontal),If(Self.OverrideMinHeight>0,Self.OverrideMinHeight, 50),140) 
        MinimumWidth: |
            =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal,200,
                If(pbMenu.CollapsedMode()=true,50,
                    If(pbMenu.OverrideExpandedWidth<=0,
                        120, 
                        pbMenu.OverrideExpandedWidth
                    )
                )
            )
        OnBeforeAction: |-
            =Switch(Upper(p_itemKey), 
                "MBBUILD", 
                    UpdateContext({mbMode: "Build"}); 
                    UpdateContext({helperMenu: "mbHelper_Build"});
                    true, 
                "MBVIEWDATA", 
                    UpdateContext({mbMode: "View"}); 
                    UpdateContext({helperMenu: "mbHelper_View"});    
                    pbMenu_BuildHelper.ItemState_UpdateAll(true);
                    pbMenu_BuildHelper.DoMenu("mbHelper_View", "mbhMenuProps");
                    pbMenu_BuildHelper.ItemState("mbhMenuProps",false);
                    true, 
                "MBEXAMPLEMENUABOUT",
                    UpdateContext({showAboutExMenu: true});
                    true,  
                "MBRESET", 
                    ForAll(col_BuildMenu As custom, 
                        RemoveIf(col_pbMenu,Lower(menuKey)=Lower(custom.menuKey));
                    );
                    Clear(col_BuildMenu);
                    true,
                "MBEXAMPLEMENU", 
                    //Note:  the code below creates the menu items, which can be rendered in any pbMenu control.   Additional properties, which affect behavior of the menu and menu items, are set on each pbMenu control placed on your screen(s).  For this demo, most of the customizable pbMenu properties are linked to on screen controls (like 'MenuOrientation') near the top of the current screen. Try changing those properties to view how it affect the layout and function of the pbMenu.
                    // ** This code is executed in the 'OnBeforeUpdate' event for the pbMenu at the very top of this screen (pbMenu_MenuBuilder)
                    // All menu data is stored in a single collection (which also means, you can add menu items using any pbMenu component, and any pbMenu component can render any menu)
                    // In order to not remove menu data from other menus in this demo, I'm just clearing the 'exampleMenu' data here
                    RemoveIf(col_pbMenu, Upper(menuKey) = Upper("exampleMenu"));
                    // The 'col_BuildMenu' is used for this demo only, and is normally not a collection the pbMenu cares about
                    RemoveIf(col_BuildMenu, Upper(menuKey) = Upper("exampleMenu"));
                    Collect(col_BuildMenu, {menuKey: "exampleMenu"});
                    
                    // Build the menu items that will render when referencing 'exampleMenu'
                    // Because the menu is getting built in response to another pbMenu.OnBeforeAction event, we're using 'Self' to refer to the pbMenu which raised the event, but since we're adding all menu items to the col_pbMenu collection (last parameter), we could change 'Self' to any pbMenu on any screen.
                    //Create an 'Info Only' menu item.  (Not Selectable)
                    Self.CreateInfoItem("exampleMenu","Example Menu",Self.ItemAppearanceChoices.Transparent,"Example Menu",true);
                    //Create a 'spacer' menu item.  (Not Selectable, No text or icon displayed)
                    Self.CreateSpacer("exampleMenu",true);
                    //Create menu item 'exConfirm1' (The last 3 argements are for requiring disabling when selected, requiring confirmation, and (true) to add to col_pbMenu collection)
                    Self.CreateMenuItem("exampleMenu","exConfirm1","Confirm","Delete",Self.ItemAppearanceChoices.Primary,Self.ItemIconStyleChoices.Filled,"Requires Confirmation",false,true,true);
                    //Create menu item 'exConfirm2' (does not require confirmation)
                    Self.CreateMenuItem("exampleMenu","exConfirm2","No Confirm","Add",Self.ItemAppearanceChoices.Primary,Self.ItemIconStyleChoices.Filled,"No Confirmation Required",false,false,true);
                    //Another spacer
                    Self.CreateSpacer("exampleMenu",true);        
                    //exDisable1, exDisable2, exDisable3 will all disable when selected, as long as the pbMenu_Build menu has 'Enable Item States' set to true (default)
                    //exDisable3 will also require a confirmation
                    Self.CreateMenuItem("exampleMenu","exDisable1","Disable 1","Money",Self.ItemAppearanceChoices.Outline,Self.ItemIconStyleChoices.Filled,"Disable on Select",true,false,true);
                    Self.CreateMenuItem("exampleMenu","exDisable2","Disable 2","ServiceBell",Self.ItemAppearanceChoices.Outline,Self.ItemIconStyleChoices.Filled,"Disable on Select",true,false,true);
                    Self.CreateMenuItem("exampleMenu","exDisable3","Confirm & Disable 3","Eraser",Self.ItemAppearanceChoices.Outline,Self.ItemIconStyleChoices.Filled,"Confirm, Disable on Select",true,true,true);
                    //the following 4 menus exist to show behavior of menu 'spillover' (if necessary, make your browser window more narrow)
                    Self.CreateMenuItem("exampleMenu","exLong1","This is a really long display name 1","Money",Self.ItemAppearanceChoices.Outline,Self.ItemIconStyleChoices.Filled,"Calculate Widget",false,true,true);
                    Self.CreateMenuItem("exampleMenu","exLong2","This is a really long display name 2","Money",Self.ItemAppearanceChoices.Outline,Self.ItemIconStyleChoices.Filled,"Calculate Widget",true,false,true);
                    Self.CreateMenuItem("exampleMenu","exLong3","This is a really long display name 3","Money",Self.ItemAppearanceChoices.Outline,Self.ItemIconStyleChoices.Filled,"Calculate Widget",true,false,true);
                    Self.CreateMenuItem("exampleMenu","exLong4","This is a really long display name 4","Money",Self.ItemAppearanceChoices.Outline,Self.ItemIconStyleChoices.Filled,"Calculate Widget",true,false,true);
            
                    UpdateContext({ignoreUnhandled:true}); Reset(toggIgnoreUnhandled);
                    UpdateContext({manageItemStates:true}); Reset(toggManageItemStates);
                    UpdateContext({enableCollapse:true}); Reset(toggEnableCollapsedState);
                    UpdateContext({currentDisplayedMenu: "exampleMenu"});
            
            
                    true, 
            
                //if the menu selection is not handled above, returning false will pass the action on to the 'DoMenu' function of the pbMenu component.
                false
            )
        OnRemoveMenuItem: =
        PerformanceLogging: =pbMenu_LogPerformance
        RemoveMenuItem: |-
            =RemoveIf(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_menuItemKey));
            Self.OnRemoveMenuItem(p_menuKey,p_menuItemKey)
        Reset: =Reset(pbMenu_MenuBuilder)
        ShowNavBackButton: =true
        ToolbarOrientation: =pbMenu_MenuBuilder.LayoutChoices.Horizontal
        Width: =Parent.Width
        Y: =40
        ZIndex: =2

    cont_MenuData As groupContainer.manualLayoutContainer:
        BorderColor: =RGBA(15, 108, 189, 1)
        BorderThickness: =2
        DropShadow: =DropShadow.Light
        Height: =Parent.Height - Self.Y - 10 -4
        RadiusBottomLeft: =4
        RadiusBottomRight: =4
        RadiusTopLeft: =4
        RadiusTopRight: =4
        Visible: =mbMode="View"
        Width: =Parent.Width - Self.X - 10 
        X: =pbMenu_BuildHelper.X + pbMenu_BuildHelper.Width + 10 
        Y: =pbMenu_BuildHelper.Y + 2 
        ZIndex: =3

        btnClearInfoFilter As Button:
            DisplayMode: =DisplayMode.Edit
            Height: =32
            OnSelect: |-
                =UpdateContext({infoSearch: ""});
                Reset(srch_pbMenuInfo)
            Text: ="Clear Filter"
            Width: =96
            X: =344
            Y: =5
            ZIndex: =1

        "txt_pbMenu_Build_JSON As 'Text input'":
            BorderColor: =RGBA(160, 64, 8, 1)
            BorderStyle: =BorderStyle.Solid
            DisplayMode: =DisplayMode.Edit
            Height: =Parent.Height - Self.Y - 10 
            Mode: ='TextInputCanvas.Mode'.Multiline
            Value: |-
                =Switch(Upper(helperView), 
                    "MENUPROPS", 
                        $"(sorted by {Char(34)}name{Char(34)}){const_CrLf}{const_CrLf}" & 
                        JSON(
                            SortByColumns(
                            With({rslt: 
                            ForAll(pbMenu_Build.Information() As item, 
                                With({srch: Lower(srch_pbMenuInfo.Value)}, 
                                    If(Len(srch)=0 || Find(srch,Lower(JSON(item)))>0, 
                                        item 
                                    )
                                )
                            )}, 
                                Filter(rslt,Len(name)>0)
                            ),"name",SortOrder.Ascending)
                            ,JSONFormat.IndentFour
                        ), 
                    Upper("menuitemsjson"), 
                        JSON(pbMenu_Build.CurrentMenuItems,JSONFormat.IndentFour)
                )
            Width: =Parent.Width - Self.X - 10 
            X: =10
            Y: =lblSeachHelp.Y + lblSeachHelp.Height + 10 
            ZIndex: =2

        "srch_pbMenuInfo As 'Text input'":
            BorderColor: =RGBA(15, 108, 189, 1)
            BorderStyle: =BorderStyle.Solid
            BorderThickness: =1
            DisplayMode: =DisplayMode.Edit
            Height: =32
            Placeholder: |-
                ="Search pbMenu_Build: Props"
            TriggerOutput: ='TextInputCanvas.TriggerOutput'.Delayed
            Value: =infoSearch
            Width: =320
            X: =10
            Y: =5
            ZIndex: =3

        lblSearchInfo As Text:
            AutoHeight: =false
            DisplayMode: =DisplayMode.Edit
            FontColor: =clr_BLUEBERRY
            Height: =34 
            Size: =12
            Text: |-
                ="Information below comes from the interactive 'building' menu and is obtained from:  'pbMenu_Build.Information()'"
            VerticalAlign: =VerticalAlign.Middle
            Weight: ='TextCanvas.Weight'.Bold
            Width: =Parent.Width - Self.X - 10 
            X: =453
            Y: =srch_pbMenuInfo.Y 
            ZIndex: =4

        lblSeachHelp As Text:
            AutoHeight: =false
            DisplayMode: =DisplayMode.Edit
            FontColor: =RGBA(106, 122, 127, 1)
            Height: =34
            PaddingLeft: =10
            Size: =12
            Text: ="(Search for any pbMenu property, function, event, or component action to view information / value of item -- for example, search for 'Input Property' to view information for items that can be set externally"
            VerticalAlign: =VerticalAlign.Middle
            Weight: ='TextCanvas.Weight'.Bold
            Width: =Parent.Width - Self.X - 10 
            X: =10
            Y: =Max(srch_pbMenuInfo.Y + srch_pbMenuInfo.Height + 5,lblSearchInfo.Y + lblSearchInfo.Height + 5)
            ZIndex: =5

    cont_CreateMenuItems As groupContainer.manualLayoutContainer:
        BorderColor: =RGBA(160, 64, 8, 1)
        BorderThickness: =2
        DropShadow: =DropShadow.Light
        Height: =Parent.Height - Self.Y - 10 - 2 
        RadiusBottomLeft: =4
        RadiusBottomRight: =4
        RadiusTopLeft: =4
        RadiusTopRight: =4
        Visible: =mbMode="Build"
        Width: =Parent.Width - Self.X - 10 
        X: =pbMenu_BuildHelper.X + pbMenu_BuildHelper.Width + 10 
        Y: =pbMenu_BuildHelper.Y + 2 
        ZIndex: =4

        pbMenu_Build As pbMenu:
            BorderColor: =clr_BLUEBERRY
            BorderWidth: =2
            BusyBehavior: =ddBusyBehavior.Selected.Value
            CancelMenuColorPalette: =cancelColorPalette
            Collapse: |-
                =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                    //determine if current state is expanded
                    With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                        With({isCollapsed: 
                            If(IsBlank(collapseRec), 
                                If(Self.EnableUserCollapse=false, 
                                    false, 
                                    pbMenu_Build.DefaultCollapsedState
                                )
                                , 
                                collapseRec.boolValue
                            )}, 
                            If(isCollapsed=false, 
                                If(IsBlank(collapseRec), 
                                    Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu_Build.ControlGUID), menuKey: pbMenu_Build.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: true,  desc: ""})
                                    , 
                                    Patch(col_pbMenuUtil, collapseRec, {boolValue:true})
                                )
                            )
                        )
                
                    )    
                )
            CollapsedMode: |-
                =//If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal || Self.EnableCollapsedState<>true, false,     
                If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal, false,     
                    With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                        If(IsBlank(collapseRec), 
                            pbMenu_Build.DefaultCollapsedState
                            , 
                            collapseRec.boolValue
                        )       
                    )
                )
            ConfirmAction: |+
                =With({Perf: {id: GUID(), start: Now(), action: $"CONFIRM ACTION: {p_menuKey}.{p_itemKey} ({p_itemDisplay})"}}, 
                    RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm");
                    Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: p_menuKey,itemKey: p_itemKey, action: "confirm", boolValue: true,  desc: p_itemDisplay});
                    If(pbMenu.PerformanceLogging=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    )
                )
                
            ConfirmationColorPalette: =confirmColorPalette
            ConfirmMode: =CountIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")>0
            CreateInfoItem: |
                =With({newMenuItem: 
                    //get menu item structure
                    {
                        menuKey: Upper(TrimEnds(p_menuKey)), 
                        ItemKey: Upper($"_info_{GUID()}"), 
                        ItemDisplayName: TrimEnds(p_itemDisplay), 
                        ItemIconName: "Info", 
                        ItemAppearance: TrimEnds(p_itemAppearance), 
                        ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
                        ItemTooltip: TrimEnds(p_itemTooltip), 
                        ItemDisabled: false, 
                        disableOnSelect: false, 
                        confirmItemAction: false
                    }}
                    , 
                    If(p_addToCollection=true, 
                        RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                        Collect(col_pbMenu,newMenuItem)
                    );
                    newMenuItem 
                )
            CreateMenuItem: |
                =With({Perf: {id: GUID(), start: Now(), action: $"CREATE MENU ITEM: {p_menuKey}.{p_ItemKey} ({p_ItemDisplayName})"}}, 
                    With({isSpacer: (Len(TrimEnds(p_ItemKey))=0)=true},     
                        With({newMenuItem: 
                            If(isSpacer, 
                                //get spacer structure (without adding -- can be added to collection below if appropriate)
                                Self.CreateSpacer(p_menuKey,false), 
                                //get menu item structure
                                {menuKey: Upper(TrimEnds(p_menuKey)), ItemKey: Upper(TrimEnds(Coalesce(p_ItemKey,$"_spacer_{GUID()}"))), ItemDisplayName: If(isSpacer,"",TrimEnds(p_ItemDisplayName)), ItemIconName: If(isSpacer," ", TrimEnds(p_ItemIconName)), ItemAppearance: TrimEnds(p_ItemAppearance), ItemIconStyle: TrimEnds(p_ItemIconStyle), ItemTooltip: TrimEnds(p_ItemTooltip), ItemDisabled: isSpacer, disableOnSelect: p_disableOnSelect, confirmItemAction: p_confirmItemAction}
                            )}, 
                            If(p_addToCollection=true, 
                                RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                                Collect(col_pbMenu,newMenuItem)
                            );
                            If(pbMenu.PerformanceLogging=true, 
                                With({endTS: Now()}, 
                                    Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                                )
                            );
                            newMenuItem 
                        )
                    )
                )
            CreateSpacer: |
                =With({Perf: {id: GUID(), start: Now(), action: $"CREATE SPACER: {p_menuKey} (Add to collection: {p_addToCollection})"}}, 
                    With({newSpacer: 
                        If(Len(TrimEnds(p_menuKey))=0, 
                            Blank(), 
                            {
                                menuKey: Upper(TrimEnds(p_menuKey)), 
                                ItemKey: $"_spacer_{GUID()}", 
                                ItemDisplayName: " ", 
                                ItemIconName: "", 
                                ItemAppearance: Self.ItemAppearanceChoices.Transparent,  
                                ItemIconStyle: Self.ItemIconStyleChoices.Outline, 
                                ItemTooltip: "", 
                                ItemDisabled: true, 
                                disableOnSelect: false, 
                                confirmItemAction: false    
                            }
                        )}, 
                        If(p_addToCollection=true && Not(IsBlank(newSpacer)), 
                            Collect(col_pbMenu,newSpacer)
                        );
                        If(pbMenu.PerformanceLogging=true, 
                            With({endTS: Now()}, 
                                Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                            )
                        );
                        newSpacer
                    )
                )
            DoMenu: |-
                =With({spinning: spin.waiting=true, spinningMsg: spin.msg}, 
                    If(Not(spinning), Set(spin, {waiting: true, msg: "Please wait ..."}));
                    With({mi: pbMenu.MenuItem(p_menuKey,p_itemKey)}, 
                        If(mi.confirmItemAction=true, 
                            If(Self.ConfirmMode() <> true, 
                                //Add 'confirm' action and waits for user to confirm or cancel
                                //cancel clears confirm action
                                //confirm calls DoMenu again, which can then move forward
                                Self.ConfirmAction(p_menuKey,p_itemKey,mi.ItemDisplayName)
                                , 
                                //clear the 'confirm' action, which is now confirmed, and 
                                //process menuItem as normal
                                RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")
                            )
                        );
                        With({doMenuHandled: 
                            If(Self.ConfirmMode() <> true, 
                                If(pbMenu.ManageItemStates = true, 
                                    pbMenu.ItemState_UpdateAll(true);
                                    If(mi.disableOnSelect=true, 
                                        pbMenu.ItemState(mi.ItemKey,false)
                                    )
                                );
                                //Raise 'OnBeforeAction'.  If handled in event on screen ('true' returned), no further action is taken.
                                //If not handled in the 'OnBeforeAction', will attempt to handle below and show error if was not handled.
                                If(Self.OnBeforeAction(p_itemKey) = true, 
                                    true
                                    , 
                                    With({handledHere: 
                                        Switch(Upper(p_itemKey), 
                                            "LAUNCHGITHUB", Launch("https://github.com/lopperman"); true, 
                                            "LAUNCHREDDIT", Launch("https://www.reddit.com/user/ITFuture"); true, 
                                            "GOOGLE", Launch("https://www.google.com"); true, 
                                            "MINAVPERF", Navigate(PerformanceLog,ScreenTransition.Fade); true, 
                
                                            //not handled
                                            Notify("NO ACTION WAS TAKEN FOR MENU ITEM: " & p_menuKey & "." & p_itemKey & " (" & mi.ItemDisplayName & ")",NotificationType.Error,5000);
                                            false
                                        )}, 
                                        handledHere
                                    )
                                );
                            )
                            }, 
                            If(Not(spinning), Set(spin,{waiting: false,msg:"Please wait ..."}));
                            doMenuHandled
                        )
                
                    );
                )
            EnableUserCollapse: =toggEnableCollapsedState.Checked
            Expand: |-
                =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                    //determine if current state is expanded
                    With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                        With({isCollapsed: 
                            If(IsBlank(collapseRec), 
                                pbMenu_Build.DefaultCollapsedState
                                , 
                                collapseRec.boolValue
                            )}, 
                            If(isCollapsed=true, 
                                If(IsBlank(collapseRec), 
                                    Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu_Build.ControlGUID), menuKey: pbMenu_Build.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: false,  desc: ""})
                                    , 
                                    Patch(col_pbMenuUtil, collapseRec, {boolValue:false})
                                )
                            )
                        )
                    )    
                )
            Fill: =RGBA(255, 255, 219, 1)
            Height: =If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal, Self.MinimumHeight(),Parent.Height - Self.Y * 2 ) 
            Information: |-
                =[
                    {
                        name: "About", 
                        type: "General pbMenu Help",
                        desc: "** NOTE: '[pbMenu]' is referenced in this documentation in relation to getting/setting/calling actions for a pbMenu component. Please remember that 'pbMenu' can never be referenced directly from a screen, and should be replaced with the name of the pbMenu component on your screen.  For example, if you added a pbMenu component to your screen, and named it 'mainMenu1', that all interactions for that menu would use 'mainMenu1', and not 'pbMenu'"        
                    },
                    {
                        name: "ToolbarOrientation", 
                        valText: Self.ToolbarOrientation, 
                        dataType: "Text", 
                        externalUse: "[pbMenu].LayoutChoices.Horizontal (default), or [pbMenu].LayoutChoices.Vertical", 
                        type: "Input Property",
                        desc: "Use to get or set the orientation of [pbMenu]"
                    },
                    {
                        name: "MinimumHeight()", 
                        valNumber: Self.MinimumHeight(), 
                        dataType: "Number", 
                        externalUse: "When in 'Horizontal' layout mode, set the pbMenu component (added to your screen) 'Height' property to be 'Self.MinimumHeight()'", 
                        type: "Output Function", 
                        desc: "Provides recommended pbMenu Height, when in Horizontal layout mode.  Note: Property 'OverrideMinHeight can be used to fine tune desired menu height."
                    },
                    {
                        name: "MinimumWidth()", 
                        valNumber: Self.MinimumWidth(), 
                        dataType: "Number", 
                        externalUse: "When in 'Vertical' layout mode, set the pbMenu component (added to your screen) 'Width' property to be 'Self.MinimumWidth()'.  This will enable the pbMenu control to automatically resize when user collapses or expands the menu.", 
                        type: "Output Function", 
                        desc: "Provides recommended pbMenu Width, when in Vertical layout mode,  Note: if you need to adjust the expanded width, use the 'OverrideExpandedWidth' property to set the desired expanded width value"
                    },
                    {
                        name: "CurrentMenuItems", 
                        valTable: Self.CurrentMenuItems, 
                        dataType: "Table", 
                        externalUse: "Reference Only", 
                        type: "Output Property",
                        desc: "Current Menu Items.   Retrieved by filtering items from 'MenuData' datasource, where menuName=[pbMenu].MenuKey"
                    },
                    {
                        name: "CancelMenuColorPalette", 
                        valColor: Self.CancelMenuColorPalette, 
                        dataType: "Color", 
                        externalUse: "Use to set color palette of Confirmation 'Cancel' button; Default is RGBA(0,0,0,0)", 
                        type: "Input Property",
                        desc: "Color Palette used when displaying 'Cancel' button for required user confirmation"
                    },
                    {
                        name: "CollapseMode()", 
                        valBoolean: Self.CollapsedMode(), 
                        dataType: "Boolean", 
                        externalUse: "Reference Only, must be called as function", 
                        type: "Output Function",
                        desc: "Returns true when 'ToolbarOrientation' is Vertical and menu is collapsed"
                    },
                    {
                        name: "DefaultCollapsedState", 
                        valBoolean: Self.DefaultCollapsedState, 
                        dataType: "Boolean", 
                        externalUse: "Use to set default collapsed state (true=collapsed, false=expanded)", 
                        type: "Input Property", 
                        desc: "When true, default state of menu will be collapsed, when menu is configured for vertical layout"
                    }, 
                    {
                        name: "EnableUserCollapse", 
                        valBoolean: Self.EnableUserCollapse, 
                        dataType: "Boolean", 
                        externalUse: "Set to 'false' to prevent vertical menu from ever displaying in collapsed/icon-only mode", 
                        type: "Input Property", 
                        desc: "Defaults to true; controls whether vertical menu can be collapsed"
                    }, 
                    {
                        name: "ConfirmationColorPalette", 
                        valColor: Self.ConfirmationColorPalette, 
                        dataType: "Color", 
                        externalUse: "Use to set color palette of Confirmation 'Confirm' button", 
                        type: "Input Property",
                        desc: "Color Palette used when displaying 'Confirm' button for required user confirmation"
                    }, 
                    {
                        name: "ConfirmMode()", 
                        valBoolean: Self.ConfirmMode(), 
                        dataType: "Boolean", 
                        externalUse: "Reference Only, must be called as function", 
                        type: "Output Function", 
                        desc: "When user has selected a menu item which requires confirmation, [pbMenu].'ConfirmMode()' will return true until user has selected 'Confirm' or 'Cancel'"
                    }, 
                    {   
                        name: "ControlGUID", 
                        valText: Self.ControlGUID, 
                        dataType: "Text", 
                        externalUse: "Reference Only.  VALUE WILL CHANGE BETWEEN SESSIONS!", 
                        type: "Output Property", 
                        desc: "Unique value which can be used at runtime only, and may update each time a screen becomes visible.  The purpose of this property is to manage specific state information"
                    }, 
                    {
                        name: "ItemAppearanceChoices", 
                        valRecord: Self.ItemAppearanceChoices, 
                        dataType: "Record", 
                        externalUse: "Use to set 'ItemAppearance' property when creating new menu items", 
                        type: "Output Property", 
                        desc: "Helper property wich can be used when setting value for 'ItemAppearance', when creating a new menu item using [pbMenu].'Create Menu Item'()"
                    }, 
                    {
                        name: "ItemIconStyleChoices", 
                        valRecord: Self.ItemIconStyleChoices, 
                        dataType: "Record", 
                        externalUse: "Use to set 'ItemIconStyle' property when creating new menu items", 
                        type: "Output Property", 
                        desc: "Helper property which can be used when setting value for 'ItemIconStyle', when creating a new menu item using [pbMenu].'Create Menu Item'"
                    }, 
                    {
                        name: "LayoutChoices", 
                        valRecord: Self.LayoutChoices, 
                        dataType: "Record", 
                        externalUse: "Helper used to set valid [pbMenu].ToolbarOrientation", 
                        type: "Output Property", 
                        desc: "Helper property which can be used when setting value of [pbMenu].ToolbarOrientation"
                    }, 
                    {
                        name: "ConfirmAction", 
                        dataType: "n/a", 
                        externalUse: "Optionally can be used to trigger a menu item selection confirmation (see desc)", 
                        type: "Component Action", 
                        desc: "Trigger action which requires user to confirm or cancel selected menu item.  Used internally by pbMenu when a menu item is selected that was created with 'confirmItemAction' = true. While not intended to be called externally, this action can be triggered outside the pbMenu component as long as the parameter arguments (p_menuKey, p_itemKey, p_itemDisplay) match a menu item which currently is being displayed in [pbMenu]"
                    }, 
                    {
                        name: "CreateMenuItem", 
                        type: "Component Action", 
                        dataType: "Record", 
                        externalUse: "Returns Menu Item Record data which is also automatically added to collection: col_pbMenu if the 'p_addToCollection' argument is true", 
                        desc: "Returns a menu item record based on provided parameter values.  By default, new menu item is not added to a data source and therefore will not be available for use.  When called with p_addToCollection=true, the new menu item will be added to col_pbMenu (default data source for [pbMenu]), and becomes available for use by any pbMenu component.", 
                        example: $"To get the correct structure (record) of a menu item you wish to add, which will be stored in an external datasource -- like SharePoint or DataVerse -- the following would return that record and NOT add it to the default MenuData datasource ('col_pbMenu'):  [pbMenu].CreateMenuItem({Char(34)}Main{Char(34)},{Char(34)}miNavBuild{Char(34)},{Char(34)}MENU BUILDER{Char(34)},{Char(34)}ArrowRight{Char(34)},[pbMenu].ItemAppearanceChoices.Primary,[pbMenu].ItemIconStyleChoices.Filled,{Char(34)}Build a Menu{Char(34)},false,false,false);, setting the last parameter to 'true' would cause the new menu item to also be added to 'col_pbMenu'"
                    }, 
                    {
                        name: "DoMenu", 
                        externalUse: "Optionally use to trigger a menu item selection (see desc)", 
                        type: "Component Action", 
                        desc: "Called when user selects a menu item which was rendered from [pbMenu].MenuData data source. Can also be called externally. When a menu item that requires user confirmation is selected, 'DoMenu' is not called until user also selects the confirmation button. When 'DoMenu' is called externally, the item key property is NOT required to correlate to a menu item currently available, as long as the pbMenu being called is able to process the 'p_ItemKey' argument in the [pbMenu].OnBeforeAction event on the current screen."
                    }, 
                    {
                        name: "ManageItemStates", 
                        valBoolean: Self.ManageItemStates, 
                        dataType: "Boolean", 
                        externalUse: "Used to enable a pbMenu to change menu item states automatically (default: true)", 
                        type: "Input Property", 
                        desc: "When set to true (default), any menu item selected which has 'disableOnSelect' property set to true, will become disabled when selected, and will become re-enabled when any other menu item is selected. When 'ManageItemStates' is set to false, the 'disableOnSelect' menu item property is ignored"
                    }, 
                    {
                        name: "ItemState", 
                        externalUse: "can be used to manually enable/disable menu items (when [pbMenu].ManageItemStates is false)", 
                        type: "Component Action", 
                        desc: "Used internally by pbMenu to enable/disable a menu item.  Can be called externally to enable/disable a menu item at any time.  Note:  When 'ManageItemStates' is set to true, pbMenu will allways re-enable all menu items when any menu item is selected."
                    }, 
                    {
                        name: "ItemState_UpdateAll", 
                        type: "Component Action", 
                        desc: "Used internally to re-enable all menu items.  Can be called externally to enable or disable all menu items.  Please remember that when 'ManageItemStates' is set to true, all menu items are enabled any time a menu item is selected.", 
                        canCall: true 
                    }, 
                    {
                        name: "MenuColorPalette", 
                        valColor: Self.MenuColorPalette, 
                        dataType: "Color", 
                        type: "Input Property", 
                        desc: "Color pallete used for menu items.  Defaults to 'PowerAppsTheme.Colors.Primary'", 
                        canSet: true 
                    }, 
                    {
                        name: "MenuData_All", 
                        valTable: Self.MenuData_All, 
                        dataType: "Table", 
                        type: "Output Property", 
                        desc: "Unfiltered records from col_pbMenu. This Table/collection contains configuration records for all menu items in all defined menus"
                    }, 
                    {
                        name: "IsBusy", 
                        valBoolean: Self.IsBusy, 
                        dataType: "Boolean", 
                        type: "Input Property", 
                        desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                    }, 
                    {
                        name: "IsBusyEnabled", 
                        valBoolean: Self.IsBusyEnabled, 
                        dataType: "Boolean", 
                        type: "Input Property", 
                        desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                    }, 
                
                    {
                        name: "BusyMessage", 
                        valText: Self.BusyMessage, 
                        dataType: "Text", 
                        type: "Input Property", 
                        desc: "The message that is displayed in the pbMenu container, when pbMenu.IsBusy=true, and pbMenu.BusyBehavior='Spinner'."
                    }, 
                    {
                        name: "BusyBehavior", 
                        valText: Self.BusyBehavior, 
                        dataType: "Text", 
                        type: "Input Property", 
                        desc: "Text value to indicate pbMenu behavior when pbMenu.IsBusy=true.  A helper property (pbMenu.BusyBehaviorChoices) can be use to set this property.  Valid value are either 'BusyBehaviorChoices.Spinning' ('Spinning'), or 'BusyBehaviorChoices.Disabled' ('Disabled').  When this property is missing or contains an invalid value, the default value ('Spinning') will be used."
                    }, 
                    {
                        name: "BusyBehaviorChoices", 
                        valRecord: Self.BusyBehaviorChoices, 
                        dataType: "Record", 
                        type: "Output Property", 
                        desc: "Helper property which contains valid choices for the pbMenu.BusyBehavior input property"
                    }, 
                    {
                        name: "ToolbarPadding", 
                        valText: Self.ToolbarPadding, 
                        dataType: "Text", 
                        type: "Input Property", 
                        desc: "Toolbar padding is managed automatically ('Medium' for Horizontal Layout, 'Small' for Vertical Layout.)  If adjustment is necessary, can be overridden ('Small', 'Medium', 'Large').  A helper property exists to select choices (ToolbarPaddingChoices).  For example, if the name of your on-screen pbMenu component was 'myMenu' and you wanted to force 'Large' padding, you would set the 'ToolbarPadding' property to: myMenu.ToolbarPaddingChoices.Large"
                    }, 
                    {
                        name: "ToolbarPaddingChoices", 
                        valRecord: Self.ToolbarPaddingChoices, 
                        dataType: "Record", 
                        type: "Output Property", 
                        desc: "Helper property which provides valid 'ToolbarPadding' choices"
                    }
                
                ]
            IsBusyEnabled: =toggIsBusyEnabled.Checked
            ItemState: |
                =With({Perf: {id: GUID(), start: Now(), action: $"ITEM STATE CHANGE: {pbMenu.MenuKey}.{p_itemKey} (enabled: {p_enabled})"}}, 
                    If(Not(StartsWith(Lower(p_itemKey),"_spacer_")) || Not(p_enabled), 
                        UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey) && Upper(ItemKey)=Upper(p_itemKey),{ItemDisabled:Not(p_enabled)})        
                    );
                
                //    RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="disable" && Upper(itemKey)=Upper(p_itemKey));
                //    With({isSpacer:StartsWith(Lower(p_itemKey),"_spacer_")}, 
                //        With({tmpMenuItem: pbMenu.MenuItem(pbMenu.MenuKey,p_itemKey), shouldDisable: If(isSpacer, true, Not(p_enabled))}, 
                //            If(p_enabled=false, 
                //                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: p_itemKey, action: "disable", boolValue: true,  desc: ""});
                //            );
                //            If(tmpMenuItem.ItemDisabled<>shouldDisable, 
                //                Patch(col_pbMenu,tmpMenuItem,{ItemDisabled:shouldDisable})
                //            )
                //        )
                //    );
                    If(pbMenu.PerformanceLogging=true && p_enablePerfLog=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    )
                )
            ItemState_UpdateAll: |
                =With({Perf: {id: GUID(), start: Now(), action: $"UPDATE ITEM STATES (ALL): {pbMenu.MenuKey} (Enabled: {p_Enabled})"}}, 
                    UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey),{ItemDisabled:Not(p_Enabled)});
                
                //    ForAll(pbMenu.MenuItems As mItem, 
                //        pbMenu.ItemState(mItem.ItemKey,p_Enabled,false)
                //    );
                
                //    pbMenu.Reset();
                //    If(pbMenu.PerformanceLogging=true, 
                //        With({endTS: Now()}, 
                //            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                //        )
                //    )
                )
            ManageItemStates: =toggManageItemStates.Checked
            MenuColorPalette: =miPrimaryColorPalette
            MenuItem: =LookUp(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_itemKey))
            MenuKey: =Coalesce(ddMenuKey.Selected.Value,"exampleMenu")
            MinimumHeight: =If(Upper(Self.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Horizontal),If(Self.OverrideMinHeight>0,Self.OverrideMinHeight, 50),140) 
            MinimumWidth: |
                =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal,200,
                    If(pbMenu.CollapsedMode()=true,50,
                        If(pbMenu.OverrideExpandedWidth<=0,
                            120, 
                            pbMenu.OverrideExpandedWidth
                        )
                    )
                )
            OnBeforeAction: |-
                =With({wasHandled: 
                    Switch(Upper(p_itemKey), 
                        "handled key 1",true,
                        false
                        )
                    }, 
                    If(wasHandled=false, 
                            Notify($"Menu Item: {Self.MenuKey}.{p_itemKey} ({Self.MenuItem(Self.MenuKey, p_itemKey).ItemDisplayName}) was selected",NotificationType.Information,2000)
                    );
                    If(toggIgnoreUnhandled.Checked,
                        true,  
                        wasHandled
                    )
                
                )
            OnRemoveMenuItem: =
            OverrideExpandedWidth: =160
            PerformanceLogging: =pbMenu_LogPerformance
            RemoveMenuItem: |-
                =RemoveIf(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_menuItemKey));
                Self.OnRemoveMenuItem(p_menuKey,p_menuItemKey)
            Reset: =Reset(pbMenu_Build)
            ShowNavBackButton: =toggShowNavBack.Checked
            ToolbarOrientation: =Coalesce(ddMenuOrientation.Selected.Value,pbMenu_BuildHelper.LayoutChoices.Horizontal)
            ToolbarPadding: =ddToolbarPadding.Selected.Value
            Visible: =true
            Width: =If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal,  Parent.Width - Self.X * 2 ,Self.MinimumWidth())
            X: =10
            Y: =10
            ZIndex: =19

        contSubBuild As groupContainer.manualLayoutContainer:
            BorderColor: =RGBA(160, 64, 8, 1)
            BorderThickness: =1
            DropShadow: =DropShadow.Light
            Height: =Parent.Height - Self.Y - 10 
            RadiusBottomLeft: =4
            RadiusBottomRight: =4
            RadiusTopLeft: =4
            RadiusTopRight: =4
            Visible: =showAboutExMenu <> true 
            Width: =Parent.Width - Self.X - 10 
            X: =If(Coalesce(ddMenuOrientation.Selected.Value,pbMenu_BuildHelper.LayoutChoices.Horizontal)="Vertical", pbMenu_Build.X + pbMenu_Build.Width + 10,10)
            Y: |-
                =txtBuildScreenInfo.Y + txtBuildScreenInfo.Height + 10 
                //If(Coalesce(ddMenuOrientation.Selected.Value,pbMenu_BuildHelper.LayoutChoices.Horizontal)="Vertical",10, pbMenu_Build.X + pbMenu_Build.Height + 10)
            ZIndex: =29

            galSelectColor As gallery.galleryVertical:
                BorderColor: =RGBA(245, 245, 245, 1)
                DelayItemLoading: =true
                FocusedBorderThickness: =0
                Height: =90
                Items: |
                    =[
                      "#FF5733", "#33FF57", "#3357FF", "#F1C40F", "#9B59B6",
                      "#1ABC9C", "#E74C3C", "#2ECC71", "#3498DB", "#F39C12",
                      "#8E44AD", "#16A085", "#C0392B", "#27AE60", "#2980B9",
                      "#D35400", "#7F8C8D", "#BDC3C7", "#34495E", "#2C3E50",
                      "#E67E22", "#95A5A6", "#ECF0F1", "#FF6F61", "#6B5B95",
                      "#88B04B", "#F7CAC9", "#92A8D1", "#955251", "#B565A7",
                      "#009B77", "#DD4124", "#45B8AC", "#EFC050", "#5B5EA6",
                      "#9B2335", "#DFCFBE", "#55B4B0", "#E15D44", "#7FCDCD"
                    ]
                Layout: =Layout.Vertical
                LoadingSpinner: =LoadingSpinner.Data
                NavigationStep: =10
                OnSelect: |
                    =With({hexSource: ThisItem.Value, HexChars: "0123456789ABCDEF"}, 
                        With(
                            {
                                tRed: 
                                    With({HexR: Upper(Mid(hexSource,2,2))}, 
                                        16 * (Find(Mid(HexR,1,1), HexChars) - 1 + Find(Mid(HexR, 2,1), HexChars) - 1)
                                    ), 
                                tGreen: 
                                    With({HexG: Upper(Mid(hexSource,4,2))}, 
                                        16 * (Find(Mid(HexG,1,1), HexChars) - 1 + Find(Mid(HexG, 2,1), HexChars) - 1)
                                    ), 
                                tBlue: 
                                    With({HexB: Upper(Mid(hexSource,6,2))}, 
                                        16 * (Find(Mid(HexB,1,1), HexChars) - 1 + Find(Mid(HexB, 2,1), HexChars) - 1)
                                    )
                            }, 
                            UpdateContext({selectedColor: ColorValue(ThisItem.Value)});
                        )
                    );
                    UpdateContext({ownR:0}); Reset(txtOwnR);
                    UpdateContext({ownG:0}); Reset(txtOwnG);
                    UpdateContext({ownB:0}); Reset(txtOwnB);
                    UpdateContext({ownA:1}); Reset(txtOwnA);
                ShowNavigation: =true
                ShowScrollbar: =false
                TemplatePadding: =2
                TemplateSize: =16
                Width: =213
                WrapCount: =10
                X: =8
                Y: =txtColorPaleteLabel.Y + txtColorPaleteLabel.Height + 10 
                ZIndex: =1

                Rectangle3 As rectangle:
                    BorderColor: =RGBA(0, 0, 0, 0)
                    BorderStyle: =BorderStyle.None
                    BorderThickness: =2
                    DisabledFill: =RGBA(161, 159, 157, 0)
                    Fill: =ColorValue(ThisItem.Value )
                    FocusedBorderThickness: =4
                    Height: =Parent.TemplateHeight
                    HoverFill: =ColorValue(ThisItem.Value)
                    OnSelect: =Select(Parent)
                    PressedFill: =ColorValue(ThisItem.Value)
                    Width: =Parent.TemplateWidth
                    ZIndex: =1

            Group1 As group:
                Height: =5
                Width: =5
                X: =-199
                Y: =-14
                ZIndex: =3

                "txtMenuName As 'Text input'":
                    BorderColor: =clr_BLUEBERRY
                    BorderStyle: =BorderStyle.Solid
                    BorderThickness: =2
                    DisplayMode: =DisplayMode.Edit
                    FontColor: =clr_BLUEBERRY
                    Height: =32
                    OnChange: |-
                        =If(Len(Self.Value)>0, 
                            UpdateContext({currentDisplayedMenu: Self.Value});
                            Reset(ddMenuKey);
                        )
                    Placeholder: ="Menu Name"
                    Value: =currentDisplayedMenu
                    Width: =150
                    X: =8
                    Y: =txtBuildCustomMenuItem.Y + txtBuildCustomMenuItem.Height + 10 
                    ZIndex: =1

                TextCanvas3 As Text:
                    Align: ='TextCanvas.Align'.Center
                    AutoHeight: =true
                    DisplayMode: =DisplayMode.Edit
                    FontColor: =RGBA(15, 108, 189, 1)
                    Height: =32
                    PaddingTop: =2
                    Size: =10
                    Text: ="Menu Name ('MenuKey')"
                    VerticalAlign: =VerticalAlign.Middle
                    Weight: ='TextCanvas.Weight'.Bold
                    Width: =txtMenuName.Width
                    X: =txtMenuName.X 
                    Y: =txtMenuName.Y + txtMenuName.Height
                    ZIndex: =2

            Group1_1 As group:
                Height: =5
                Width: =5
                X: =-199
                Y: =-14
                ZIndex: =6

                "txtMenuItemKey As 'Text input'":
                    BorderColor: =RGBA(15, 108, 189, 1)
                    BorderStyle: =BorderStyle.Solid
                    BorderThickness: =1
                    DisplayMode: =DisplayMode.Edit
                    Height: =32
                    Placeholder: ="Menu Item Key"
                    Width: =120
                    X: =166
                    Y: =txtBuildCustomMenuItem.Y + txtBuildCustomMenuItem.Height + 10 
                    ZIndex: =4

                TextCanvas3_1 As Text:
                    Align: ='TextCanvas.Align'.Center
                    AutoHeight: =true
                    DisplayMode: =DisplayMode.Edit
                    FontColor: =RGBA(15, 108, 189, 1)
                    Height: =32
                    PaddingTop: =2
                    Size: =10
                    Text: ="Menu Item Key"
                    VerticalAlign: =VerticalAlign.Middle
                    Weight: ='TextCanvas.Weight'.Bold
                    Width: =txtMenuItemKey.Width
                    X: =txtMenuItemKey.X 
                    Y: =txtMenuItemKey.Y + txtMenuItemKey.Height
                    ZIndex: =5

            Group2 As group:
                Height: =5
                Width: =5
                X: =-199
                Y: =-14
                ZIndex: =9

                ddItemAppearance As Dropdown.pcfdataset:
                    BorderColor: =RGBA(15, 108, 189, 1)
                    BorderStyle: =BorderStyle.Solid
                    BorderThickness: =1
                    DefaultSelectedItems: =[pbMenu_Build.ItemAppearanceChoices.Primary]
                    DisplayMode: =DisplayMode.Edit
                    Height: =32
                    Items: =ColumnNames(ParseJSON((JSON(pbMenu_BuildHelper.ItemAppearanceChoices))))
                    Width: =120
                    X: =txtMenuItemTooltip.X + txtMenuItemTooltip.Width + 5 
                    Y: =txtBuildCustomMenuItem.Y + txtBuildCustomMenuItem.Height + 10 
                    ZIndex: =7

                TextCanvas3_3 As Text:
                    Align: ='TextCanvas.Align'.Center
                    AutoHeight: =true
                    DisplayMode: =DisplayMode.Edit
                    FontColor: =RGBA(15, 108, 189, 1)
                    Height: =32
                    PaddingTop: =2
                    Size: =10
                    Text: ="Menu Item Appearance"
                    VerticalAlign: =VerticalAlign.Middle
                    Weight: ='TextCanvas.Weight'.Bold
                    Width: =ddItemAppearance.Width
                    X: =ddItemAppearance.X 
                    Y: =ddItemAppearance.Y + ddItemAppearance.Height
                    ZIndex: =8

            Group1_2 As group:
                Height: =5
                Width: =5
                X: =-199
                Y: =-14
                ZIndex: =13

                "txtMenuItemDisplay As 'Text input'":
                    BorderColor: =RGBA(15, 108, 189, 1)
                    BorderStyle: =BorderStyle.Solid
                    BorderThickness: =1
                    DisplayMode: =DisplayMode.Edit
                    Height: =32
                    Placeholder: ="Menu Item Display"
                    Width: =120
                    X: =txtMenuItemKey.X + txtMenuItemKey.Width + 5 
                    Y: =txtBuildCustomMenuItem.Y + txtBuildCustomMenuItem.Height + 10 
                    ZIndex: =11

                TextCanvas3_2 As Text:
                    Align: ='TextCanvas.Align'.Center
                    AutoHeight: =true
                    DisplayMode: =DisplayMode.Edit
                    FontColor: =RGBA(15, 108, 189, 1)
                    Height: =32
                    PaddingTop: =2
                    Size: =10
                    Text: ="Menu Item Display"
                    VerticalAlign: =VerticalAlign.Middle
                    Weight: ='TextCanvas.Weight'.Bold
                    Width: =txtMenuItemDisplay.Width
                    X: =txtMenuItemDisplay.X 
                    Y: =txtMenuItemDisplay.Y + txtMenuItemDisplay.Height
                    ZIndex: =12

            Group1_4 As group:
                Height: =5
                Width: =5
                X: =-199
                Y: =-14
                ZIndex: =19

                "txtMenuItemTooltip As 'Text input'":
                    BorderColor: =RGBA(15, 108, 189, 1)
                    BorderStyle: =BorderStyle.Solid
                    BorderThickness: =1
                    DisplayMode: =DisplayMode.Edit
                    Height: =32
                    Placeholder: ="Tooltip"
                    Width: =150
                    X: =txtMenuItemDisplay.X + txtMenuItemDisplay.Width + 5 
                    Y: =txtBuildCustomMenuItem.Y + txtBuildCustomMenuItem.Height + 10 
                    ZIndex: =17

                TextCanvas3_6 As Text:
                    Align: ='TextCanvas.Align'.Center
                    AutoHeight: =true
                    DisplayMode: =DisplayMode.Edit
                    FontColor: =RGBA(15, 108, 189, 1)
                    Height: =32
                    PaddingTop: =2
                    Size: =10
                    Text: ="Tooltip"
                    VerticalAlign: =VerticalAlign.Middle
                    Weight: ='TextCanvas.Weight'.Bold
                    Width: =txtMenuItemTooltip.Width
                    X: =txtMenuItemTooltip.X 
                    Y: =txtMenuItemTooltip.Y + txtMenuItemTooltip.Height
                    ZIndex: =18

            Group2_1 As group:
                Height: =5
                Width: =5
                X: =-199
                Y: =-14
                ZIndex: =22

                ddIconStyle As Dropdown.pcfdataset:
                    BorderColor: =RGBA(15, 108, 189, 1)
                    BorderStyle: =BorderStyle.Solid
                    BorderThickness: =1
                    DefaultSelectedItems: =[pbMenu_Build.ItemIconStyleChoices.Filled]
                    DisplayMode: =DisplayMode.Edit
                    Height: =32
                    Items: =ColumnNames(ParseJSON((JSON(pbMenu_BuildHelper.ItemIconStyleChoices))))
                    Width: =120
                    X: =ddItemAppearance.X + ddItemAppearance.Width + 5 
                    Y: =txtBuildCustomMenuItem.Y + txtBuildCustomMenuItem.Height + 10 
                    ZIndex: =20

                TextCanvas3_7 As Text:
                    Align: ='TextCanvas.Align'.Center
                    AutoHeight: =true
                    DisplayMode: =DisplayMode.Edit
                    FontColor: =RGBA(15, 108, 189, 1)
                    Height: =32
                    PaddingTop: =2
                    Size: =10
                    Text: ="Icon Style"
                    VerticalAlign: =VerticalAlign.Middle
                    Weight: ='TextCanvas.Weight'.Bold
                    Width: =ddIconStyle.Width
                    X: =ddIconStyle.X
                    Y: =ddIconStyle.Y + ddIconStyle.Height
                    ZIndex: =21

            ddMenuOrientation As Dropdown.pcfdataset:
                BasePaletteColor: =
                BorderColor: =RGBA(160, 64, 8, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                DefaultSelectedItems: =[pbMenu_Build.LayoutChoices.Horizontal]
                DisplayMode: =DisplayMode.Edit
                Height: =32
                Items: =ColumnNames(ParseJSON((JSON(pbMenu_BuildHelper.LayoutChoices))))
                Width: =120
                X: =ddMenuKey.X + ddMenuKey.Width + 5 
                Y: =ddMenuKey.Y 
                ZIndex: =23

            TextCanvas3_8 As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =true
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(160, 64, 8, 1)
                Height: =32
                PaddingTop: =2
                Size: =10
                Text: ="Menu Orientation"
                VerticalAlign: =VerticalAlign.Middle
                Weight: ='TextCanvas.Weight'.Bold
                Width: =ddMenuOrientation.Width
                X: =ddMenuOrientation.X 
                Y: =ddMenuOrientation.Y + ddMenuOrientation.Height
                ZIndex: =24

            toggDisableItemOnSelect As Toggle:
                BasePaletteColor: =
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(15, 108, 189, 1)
                FontSize: =12
                FontWeight: =FontWeight.Bold
                Height: =32
                Label: ="Disable Item On Select"
                OnCheck: =false
                OnUncheck: =false
                ToggleSize: =14
                Width: =200
                X: =220
                Y: =TextCanvas3.Y + TextCanvas3.Height + 0
                ZIndex: =25

            "txtMIJson As 'Text input'":
                BasePaletteColor: =
                BorderColor: =RGBA(106, 122, 127, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                DisplayMode: =DisplayMode.Edit
                Height: =Parent.Height - Self.Y - 10 
                Mode: ='TextInputCanvas.Mode'.Multiline
                Value: |-
                    =$"(JSON/Record that will be added to col_BuildMenu)" & const_CrLf & const_CrLf & 
                    
                    With({tmpRec: 
                        {
                            ItemAppearance: $"{Coalesce(ddItemAppearance.Selected.Value, "Primary")}",
                            ItemDisabled: false,
                            ItemDisplayName: $"{Coalesce(txtMenuItemDisplay.Value,"[display name]")}",
                            ItemIconName: $"{Coalesce(ddIconName.Selected.Value,"GridDots")}",
                            ItemIconStyle: $"{ddIconStyle.Selected.Value}",
                            ItemKey: $"{Coalesce(txtMenuItemKey.Value,"[key]")}",
                            ItemTooltip: $"{txtMenuItemTooltip.Value}", 
                            confirmItemAction: true, 
                            disabledOnSelect: toggDisableItemOnSelect.Checked, 
                            menuKey: $"{Coalesce(txtMenuName.Value,"menu name")}"
                        }}, 
                        JSON(tmpRec,JSONFormat.IndentFour)
                    )
                Width: =txtJSONLabel.Width
                X: =txtJSONLabel.X 
                Y: =txtJSONLabel.Y + txtJSONLabel.Height + 10 
                ZIndex: =26

            tblTempMenuItems As Table.pcfdataset:
                DateOnlyFormat: ='PowerAppsOneGrid.DateOnlyFormat'.ShortDate
                DateTimeFormat: ='PowerAppsOneGrid.DateTimeFormat'.ShortDateTime
                DisplayMode: =DisplayMode.Edit
                EnableMultipleSelection: ='PowerAppsOneGrid.EnableMultipleSelection'.Enable
                EnableRangeSelection: ='PowerAppsOneGrid.EnableRangeSelection'.Disable
                FontSize: =11
                HeaderFontColor: =RGBA(15, 108, 189, 1)
                HeaderFontSize: =12
                HeaderFontWeight: =FontWeight.Bold
                Height: =Parent.Height - Self.Y - 10 
                Items: =Filter(col_pbMenu,Upper(menuKey)=Upper(pbMenu_Build.MenuKey))
                NoDataText: ="no menu items"
                onCellValueChange: =false
                onFilter: =false
                onNavigate: =false
                onRowSelect: =false
                onSave: =false
                OnSelect: =false
                ReflowBehavior: ='PowerAppsOneGrid.ReflowBehavior'.GridOnly
                ShowAvatar: ="no"
                Width: =Parent.Width - Self.X - 10 
                X: =txtMIJson.X + txtMIJson.Width + 10 
                Y: =txtMIJson.Y 
                ZIndex: =27

                menuKey3 As PowerAppsOneGridTemplate_dataField.textualColumn:
                    FieldDisplayName: ="menuKey"
                    FieldName: ="menuKey"
                    FieldType: ="s"
                    FieldVariantName: ="textualColumn"
                    Order: =1
                    Width: =150
                    ZIndex: =29

                ItemKey2 As PowerAppsOneGridTemplate_dataField.textualColumn:
                    FieldDisplayName: ="ItemKey"
                    FieldName: ="ItemKey"
                    FieldType: ="s"
                    FieldVariantName: ="textualColumn"
                    Order: =2
                    Width: =150
                    ZIndex: =30

                ItemDisplayName2 As PowerAppsOneGridTemplate_dataField.textualColumn:
                    FieldDisplayName: ="ItemDisplayName"
                    FieldName: ="ItemDisplayName"
                    FieldType: ="s"
                    FieldVariantName: ="textualColumn"
                    Order: =3
                    Width: =0
                    ZIndex: =31

                ItemIconStyle1 As PowerAppsOneGridTemplate_dataField.textualColumn:
                    FieldDisplayName: ="ItemIconStyle"
                    FieldName: ="ItemIconStyle"
                    FieldType: ="s"
                    FieldVariantName: ="textualColumn"
                    Order: =8
                    Width: =0
                    ZIndex: =73

                ItemIconName1 As PowerAppsOneGridTemplate_dataField.textualColumn:
                    FieldDisplayName: ="ItemIconName"
                    FieldName: ="ItemIconName"
                    FieldType: ="s"
                    FieldVariantName: ="textualColumn"
                    Order: =7
                    Width: =0
                    ZIndex: =74

                ItemAppearance1 As PowerAppsOneGridTemplate_dataField.textualColumn:
                    FieldDisplayName: ="ItemAppearance"
                    FieldName: ="ItemAppearance"
                    FieldType: ="s"
                    FieldVariantName: ="textualColumn"
                    Order: =6
                    Width: =0
                    ZIndex: =75

                disableOnSelect1 As PowerAppsOneGridTemplate_dataField.textualColumn:
                    FieldDisplayName: ="disableOnSelect"
                    FieldName: ="disableOnSelect"
                    FieldType: ="b"
                    FieldVariantName: ="textualColumn"
                    Order: =5
                    Width: =0
                    ZIndex: =76

                confirmItemAction1 As PowerAppsOneGridTemplate_dataField.textualColumn:
                    FieldDisplayName: ="confirmItemAction"
                    FieldName: ="confirmItemAction"
                    FieldType: ="b"
                    FieldVariantName: ="textualColumn"
                    Order: =4
                    Width: =0
                    ZIndex: =77

            Rectangle1 As rectangle:
                BorderColor: =RGBA(160, 64, 8, 1)
                BorderThickness: =2
                DisabledFill: =RGBA(161, 159, 157, 1)
                Fill: =RGBA(160, 64, 8, 1)
                FocusedBorderThickness: =4
                Height: =2
                HoverFill: =RGBA(0, 120, 212, 1)
                PressedFill: =RGBA(0, 120, 212, 1)
                Width: =Parent.Width - Self.X * 2 
                X: =10
                Y: =98
                ZIndex: =30

            ddBusyBehavior As Dropdown.pcfdataset:
                BasePaletteColor: =
                BorderColor: =RGBA(15, 108, 189, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                DefaultSelectedItems: =[pbMenu_Build.BusyBehaviorChoices.Spinning]
                DisplayMode: =DisplayMode.Edit
                Height: =32
                Items: =ColumnNames(ParseJSON((JSON(pbMenu_BuildHelper.BusyBehaviorChoices))))
                Width: =110
                X: =ddMenuOrientation.X + ddMenuOrientation.Width + 5 
                Y: =ddMenuKey.Y 
                ZIndex: =31

            TextCanvas3_4 As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =true
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(15, 108, 189, 1)
                Height: =32
                PaddingTop: =2
                Size: =10
                Text: ="Busy Behavior"
                VerticalAlign: =VerticalAlign.Middle
                Weight: ='TextCanvas.Weight'.Bold
                Width: =ddBusyBehavior.Width
                X: =ddBusyBehavior.X 
                Y: =ddBusyBehavior.Y + ddBusyBehavior.Height
                ZIndex: =32

            toggSimulateBusy As Toggle:
                BasePaletteColor: =RGBA(246, 142, 104, 1)
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(160, 64, 8, 1)
                FontSize: =12
                FontWeight: =FontWeight.Bold
                Height: =26  
                Label: ="Simulate App Busy"
                OnCheck: |-
                    =Set(spin, {waiting: true, msg: $"({Text(Now(),"hh:mm:ss am/pm")}) Please Wait ..."})
                OnUncheck: |-
                    =Set(spin, {waiting: false, msg: "Please Wait ..."})
                ToggleSize: =14
                Width: =180
                X: =10
                Y: =68
                ZIndex: =33

            ddMenuKey As Dropdown.pcfdataset:
                BasePaletteColor: =clr_BLUEBERRY
                BorderColor: =clr_BLUEBERRY
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =2
                DefaultSelectedItems: |-
                    =[currentDisplayedMenu]
                    
                    //If(CountIf(col_BuildMenu,true)=0,[Blank()],[First(col_BuildMenu).menuKey]) 
                DisplayMode: =If(CountIf(col_BuildMenu,true)=0,DisplayMode.Disabled, DisplayMode.Edit)
                Height: =32
                Items: =SortByColumns(Distinct(col_BuildMenu,menuKey),"Value") 
                OnChange: |-
                    =If(Not(IsBlankOrError(Self.Selected.Value)), 
                        UpdateContext({currentDisplayedMenu:Self.Selected.Value});
                        Reset(txtMenuName)
                    )
                Width: =150
                X: =10
                Y: =8
                ZIndex: =35

                Value1 As PowerApps_CoreControls_DropdownCanvasTemplate_dataField.textualColumn:
                    FieldDisplayName: ="Value"
                    FieldName: ="Value"
                    FieldType: ="s"
                    FieldVariantName: ="textualColumn"
                    Order: =1
                    ZIndex: =78

            TextCanvas3_9 As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =true
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(160, 64, 8, 1)
                Height: =32
                PaddingTop: =2
                Size: =10
                Text: ="Choose Custom Menu"
                VerticalAlign: =VerticalAlign.Middle
                Weight: ='TextCanvas.Weight'.Bold
                Width: =ddMenuKey.Width
                X: =ddMenuKey.X 
                Y: =ddMenuKey.Y + ddMenuKey.Height
                ZIndex: =36

            txtSelectedColor As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =true
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(15, 108, 189, 1)
                Height: =32
                PaddingTop: =2
                Size: =12
                Text: ="SELECTED COLOR"
                VerticalAlign: =VerticalAlign.Top
                Weight: ='TextCanvas.Weight'.Bold
                Width: =ddBusyBehavior.Width
                X: =8
                Y: =galSelectColor.Y + galSelectColor.Height + 3
                ZIndex: =37

            Rectangle4 As rectangle:
                BorderColor: =RGBA(0, 0, 0, 0)
                BorderStyle: =BorderStyle.None
                BorderThickness: =2
                DisabledFill: =RGBA(161, 159, 157, 1)
                Fill: |-
                    =Coalesce(If(Not(IsBlank(customColor)), customColor, selectedColor)
                    ,ColorValue("#247afd"))
                FocusedBorderThickness: =4
                Height: =18
                HoverFill: =RGBA(0, 120, 212, 1)
                PressedFill: =RGBA(0, 120, 212, 1)
                Width: =92
                X: =128
                Y: =galSelectColor.Y + galSelectColor.Height + 5 
                ZIndex: =38

            ddToolbarPadding As Dropdown.pcfdataset:
                BasePaletteColor: =
                BorderColor: =RGBA(160, 64, 8, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                DefaultSelectedItems: =["Default"]
                DisplayMode: =DisplayMode.Edit
                Height: =32
                Items: |-
                    =ColumnNames(ParseJSON((JSON({Default: "Default", Small: 'Toolbar.Padding'.Small,Medium: 'Toolbar.Padding'.Medium,Large: 'Toolbar.Padding'.Large}))))
                Width: =100
                X: =ddBusyBehavior.X + ddBusyBehavior.Width + 5 
                Y: =ddMenuKey.Y 
                ZIndex: =39

            TextCanvas3_11 As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =true
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(160, 64, 8, 1)
                Height: =32
                PaddingTop: =2
                Size: =10
                Text: ="Toolbar Padding"
                VerticalAlign: =VerticalAlign.Middle
                Weight: ='TextCanvas.Weight'.Bold
                Width: =ddToolbarPadding.Width
                X: =ddToolbarPadding.X 
                Y: =ddToolbarPadding.Y + ddToolbarPadding.Height
                ZIndex: =40

            toggShowNavBack As Toggle:
                BasePaletteColor: =RGBA(246, 142, 104, 1)
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(160, 64, 8, 1)
                FontSize: =12
                FontWeight: =FontWeight.Bold
                Height: =26  
                Label: ="Show 'Back' Button"
                OnCheck: =
                OnUncheck: =
                ToggleSize: =14
                Width: =200
                X: =toggEnableCollapsedState.X + toggEnableCollapsedState.Width
                Y: =toggSimulateBusy.Y 
                ZIndex: =42

            toggManageItemStates As Toggle:
                BasePaletteColor: =RGBA(246, 142, 104, 1)
                Checked: =manageItemStates
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(160, 64, 8, 1)
                FontSize: =12
                FontWeight: =FontWeight.Bold
                Height: =26  
                Label: ="Manage Item States"
                OnCheck: =
                OnUncheck: =
                ToggleSize: =14
                Width: =200
                X: =toggShowNavBack.X + toggShowNavBack.Width
                Y: =toggSimulateBusy.Y 
                ZIndex: =43

            toggRequireConfirmation As Toggle:
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(15, 108, 189, 1)
                FontSize: =12
                FontWeight: =FontWeight.Bold
                Height: =32
                Label: |
                    ="Require Confirmation"
                OnCheck: =false
                OnUncheck: =false
                ToggleSize: =14
                Width: =200
                X: =8
                Y: =TextCanvas3.Y + TextCanvas3.Height + 0
                ZIndex: =44

            toggEnableCollapsedState As Toggle:
                BasePaletteColor: =RGBA(246, 142, 104, 1)
                Checked: =enableCollapse 
                DisplayMode: =If(ddMenuOrientation.Selected.Value <> pbMenu_Build.LayoutChoices.Vertical,DisplayMode.Disabled, DisplayMode.Edit)
                FontColor: =RGBA(160, 64, 8, 1)
                FontSize: =12
                FontWeight: =FontWeight.Bold
                Height: =26  
                Label: ="Enabled Collapse"
                OnCheck: =
                OnUncheck: =
                ToggleSize: =14
                Width: =180
                X: =toggSimulateBusy.X + toggSimulateBusy.Width
                Y: =toggSimulateBusy.Y 
                ZIndex: =45

            ddIconName As Dropdown.pcfdataset:
                BorderColor: =RGBA(15, 108, 189, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                DefaultSelectedItems: =["GridDots"]
                DisplayMode: =DisplayMode.Edit
                Height: =32
                Items: =["Add","Airplane","AppsListDetail","AppsList","ArrowClockwise","ArrowDownload","ArrowDown","ArrowExit","ArrowLeft","ArrowReset","ArrowRight","ArrowSort","ArrowSync","ArrowUndo","ArrowUp","Attach","CalendarAdd","Calendar", "Camera", "Cart", "Chat", "CheckmarkCircle", "Checkmark", "ChevronDown", "ChevronLeft", "ChevronRight", "ChevronUp", "Circle", "ClockAlarm", "Clock", "Copy", "Database", "Delete", "DismissCircle", "Dismiss", "DocumentAdd", "DocumentBulletList", "DocumentPdf", "Document", "Edit", "EmojiSmileSlight", "Eraser", "ErrorCircle", "Eye", "Filter", "GlobeArrowUp", "GlobeError", "GlobeProhibited", "Globe", "GlobeSync", "GlobeWarning", "GridDots", "History", "Home", "Info", "Link", "Mail", "Money", "MoreHorizontal", "Open", "PeopleAdd", "People", "Person", "Print", "Question", "SaveCopy", "Save", "Search", "Send", "ServiceBell", "Settings", "TextCaseTitle", "Warning"]
                Width: =140
                X: =ddIconStyle.X + ddIconStyle.Width + 5 
                Y: =txtBuildCustomMenuItem.Y + txtBuildCustomMenuItem.Height + 10 
                ZIndex: =47

            TextCanvas3_13 As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =true
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(15, 108, 189, 1)
                Height: =32
                PaddingTop: =2
                Size: =10
                Text: ="Icon Name"
                VerticalAlign: =VerticalAlign.Middle
                Weight: ='TextCanvas.Weight'.Bold
                Width: =ddIconName.Width
                X: =ddIconName.X
                Y: =ddIconName.Y + ddIconName.Height
                ZIndex: =48

            btnSelectedColor As Button:
                BasePaletteColor: |
                    =If(Not(IsBlank(customColor)), customColor, selectedColor)
                DisplayMode: =DisplayMode.Edit
                Height: =34
                OnSelect: =
                Text: ="Color Palette"
                Width: =213
                X: =8
                Y: =Rectangle4.Y + Rectangle4.Height + 5 
                ZIndex: =56

            btnMenuItemColor As Button:
                BasePaletteColor: =miPrimaryColorPalette
                DisplayMode: =DisplayMode.Edit
                FontSize: =12
                Height: =26
                OnSelect: |-
                    =UpdateContext({miPrimaryColorPalette: Rectangle4.Fill})
                Text: ="Menu Item Color" 
                Width: =160
                X: =ddToolbarPadding.X + ddToolbarPadding.Width + 5 
                Y: =8
                ZIndex: =57

            btnConfirmColor As Button:
                BasePaletteColor: =confirmColorPalette
                DisplayMode: =DisplayMode.Edit
                FontSize: =12
                Height: =26
                OnSelect: |-
                    =UpdateContext({confirmColorPalette: Rectangle4.Fill})
                Text: ="Confirm Button Color" 
                Width: =160
                X: =btnMenuItemColor.X + btnMenuItemColor.Width + 5 
                Y: =8
                ZIndex: =58

            txtSelectedColor_1 As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =true
                BorderColor: =RGBA(15, 108, 189, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(15, 108, 189, 1)
                Height: =32
                PaddingTop: =2
                Size: =10
                Text: ="CLICK TO SET COLOR TO SELECTED PALETTE COLOR BELOW"
                VerticalAlign: =VerticalAlign.Middle
                Weight: ='TextCanvas.Weight'.Bold
                Width: =btnConfirmColor.X + btnConfirmColor.Width - Self.X 
                X: =btnMenuItemColor.X 
                Y: =38
                ZIndex: =59

            Icon1 As Icon:
                DisplayMode: =DisplayMode.Edit
                Height: =32
                Icon: =ddIconName.Selected.Value
                Width: =32
                X: =ddIconName.X + ddIconName.Width + 5 
                Y: =txtBuildCustomMenuItem.Y + txtBuildCustomMenuItem.Height + 10 
                ZIndex: =60

            toggIgnoreUnhandled As Toggle:
                BasePaletteColor: =RGBA(246, 142, 104, 1)
                Checked: =ignoreUnhandled
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(160, 64, 8, 1)
                FontSize: =12
                FontWeight: =FontWeight.Bold
                Height: =26  
                Label: ="Ignore Unhandled Items"
                OnCheck: =
                OnUncheck: =
                ToggleSize: =14
                Width: =220
                X: =toggManageItemStates.X + toggManageItemStates.Width
                Y: =toggManageItemStates.Y 
                ZIndex: =61

            txtBuildCustomMenuItem As Text:
                Align: ="Start"
                AutoHeight: =true
                BorderColor: =RGBA(106, 122, 127, 1)
                BorderRadius: =4
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Fill: =RGBA(232, 233, 235, 1)
                Font: =""
                FontColor: =clr_BLUEBERRY
                FontItalic: =false
                FontStrikethrough: =false
                FontUnderline: =false
                Height: =
                PaddingLeft: =10
                Size: =14
                TabIndex: =0
                Text: ="** CREATE MENU ITEM ** Use this section, with the option in the far left vertical menu, to create new menu items. (Create multiple menus by using different 'Menu Names', then use the 'Choose Custom Menu' dropdown above, to select which menu to render)"
                Tooltip: =""
                VerticalAlign: =VerticalAlign.Middle
                Visible: =true
                Weight: ='TextCanvas.Weight'.Bold
                Width: =Parent.Width - Self.X - 10 
                Wrap: =true
                X: =10
                Y: =108
                ZIndex: =62

            Rectangle1_1 As rectangle:
                BorderColor: =RGBA(160, 64, 8, 1)
                BorderThickness: =2
                DisabledFill: =RGBA(161, 159, 157, 1)
                Fill: =RGBA(160, 64, 8, 1)
                FocusedBorderThickness: =4
                Height: =2
                HoverFill: =RGBA(0, 120, 212, 1)
                PressedFill: =RGBA(0, 120, 212, 1)
                Width: =Parent.Width - Self.X * 2 
                X: =10
                Y: =toggRequireConfirmation.Y + toggRequireConfirmation.Height + Self.Height
                ZIndex: =63

            "txtOwnR As 'Text input'":
                Align: =Align.Center
                BasePaletteColor: =
                BorderColor: =RGBA(215, 58, 60, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                DisplayMode: =DisplayMode.Edit
                FontColor: =RGBA(215, 58, 60, 1)
                FontSize: =12
                FontWeight: =FontWeight.Bold
                Height: =32
                OnChange: |-
                    =If(txtCustomColorValid.Value="CUSTOM COLOR VALID", UpdateContext({customColor: RGBA(Int(txtOwnR.Value),Int(txtOwnG.Value),Int(txtOwnB.Value),If(Value(txtOwnA.Value) <=1,Value(txtOwnA.Value),Value(txtOwnA.Value)/100))}), UpdateContext({customColor:Blank()}))
                Placeholder: ="R"
                TriggerOutput: ='TextInputCanvas.TriggerOutput'.FocusOut
                Value: =ownR
                Width: =50  
                X: =7
                Y: =txtEnterOwnColor.Y + txtEnterOwnColor.Height + 5 
                ZIndex: =64

            "txtOwnG As 'Text input'":
                AccessibleLabel: =""
                Align: =Align.Center
                Appearance: ="FilledDarker"
                BorderColor: =RGBA(52, 152, 47, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =RGBA(52, 152, 47, 1)
                FontItalic: =false
                FontSize: =12
                FontStrikethrough: =false
                FontUnderline: =false
                FontWeight: =FontWeight.Bold
                Height: =32
                MaxLength: =-1
                Mode: ="SingleLine"
                OnChange: |-
                    =If(txtCustomColorValid.Value="CUSTOM COLOR VALID", UpdateContext({customColor: RGBA(Int(txtOwnR.Value),Int(txtOwnG.Value),Int(txtOwnB.Value),If(Value(txtOwnA.Value) <=1,Value(txtOwnA.Value),Value(txtOwnA.Value)/100))}), UpdateContext({customColor:Blank()}))
                Placeholder: ="G"
                Required: =false
                TabIndex: =0
                Tooltip: =""
                TriggerOutput: ='TextInputCanvas.TriggerOutput'.FocusOut
                Type: ="Text"
                ValidationState: ="None"
                Value: =ownG
                Visible: =true
                Width: =50  
                X: =61
                Y: =txtEnterOwnColor.Y + txtEnterOwnColor.Height + 5 
                ZIndex: =65

            "txtOwnB As 'Text input'":
                AccessibleLabel: =""
                Align: =Align.Center
                Appearance: ="FilledDarker"
                BorderColor: =RGBA(40, 134, 222, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =RGBA(40, 134, 222, 1)
                FontItalic: =false
                FontSize: =12
                FontStrikethrough: =false
                FontUnderline: =false
                FontWeight: =FontWeight.Bold
                Height: =32
                MaxLength: =-1
                Mode: ="SingleLine"
                OnChange: |-
                    =If(txtCustomColorValid.Value="CUSTOM COLOR VALID", UpdateContext({customColor: RGBA(Int(txtOwnR.Value),Int(txtOwnG.Value),Int(txtOwnB.Value),If(Value(txtOwnA.Value) <=1,Value(txtOwnA.Value),Value(txtOwnA.Value)/100))}), UpdateContext({customColor:Blank()}))
                Placeholder: ="B"
                Required: =false
                TabIndex: =0
                Tooltip: =""
                TriggerOutput: ='TextInputCanvas.TriggerOutput'.FocusOut
                Type: ="Text"
                ValidationState: ="None"
                Value: =ownB
                Visible: =true
                Width: =50  
                X: =115
                Y: =txtEnterOwnColor.Y + txtEnterOwnColor.Height + 5 
                ZIndex: =66

            "txtOwnA As 'Text input'":
                AccessibleLabel: =""
                Align: =Align.Center
                Appearance: ="FilledDarker"
                BorderColor: =RGBA(106, 122, 127, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =RGBA(106, 122, 127, 1)
                FontItalic: =false
                FontSize: =12
                FontStrikethrough: =false
                FontUnderline: =false
                FontWeight: =FontWeight.Bold
                Height: =32
                MaxLength: =-1
                Mode: ="SingleLine"
                OnChange: |-
                    =If(txtCustomColorValid.Value="CUSTOM COLOR VALID", UpdateContext({customColor: RGBA(Int(txtOwnR.Value),Int(txtOwnG.Value),Int(txtOwnB.Value),If(Value(txtOwnA.Value) <=1,Value(txtOwnA.Value),Value(txtOwnA.Value)/100))}), UpdateContext({customColor:Blank()}))
                Placeholder: ="A"
                Required: =false
                TabIndex: =0
                Tooltip: =""
                TriggerOutput: ='TextInputCanvas.TriggerOutput'.FocusOut
                Type: ="Text"
                ValidationState: ="None"
                Value: =ownA
                Visible: =true
                Width: =50  
                X: =169
                Y: =txtEnterOwnColor.Y + txtEnterOwnColor.Height + 5 
                ZIndex: =67

            txtEnterOwnColor As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =true
                BorderStyle: =""
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =RGBA(15, 108, 189, 1)
                FontItalic: =false
                FontStrikethrough: =false
                FontUnderline: =false
                Height: =32
                PaddingTop: =2
                Size: =12
                TabIndex: =0
                Text: ="Or, Enter your own"
                Tooltip: =""
                VerticalAlign: =VerticalAlign.Middle
                Visible: =true
                Weight: ='TextCanvas.Weight'.Bold
                Width: =btnSelectedColor.Width
                Wrap: =true
                X: =btnSelectedColor.X 
                Y: =btnSelectedColor.Y + btnSelectedColor.Height + 5
                ZIndex: =68

            "txtCustomColorValid As 'Text input'":
                AccessibleLabel: =""
                Align: =Align.Center
                Appearance: ="FilledDarker"
                BorderColor: =RGBA(52, 152, 47, 1)
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =RGBA(52, 152, 47, 1)
                FontItalic: =false
                FontSize: =12
                FontStrikethrough: =false
                FontUnderline: =false
                FontWeight: =FontWeight.Bold
                Height: =28
                MaxLength: =-1
                Mode: ='TextInputCanvas.Mode'.Multiline
                OnChange: =
                Placeholder: =
                Required: =false
                TabIndex: =0
                Tooltip: =""
                TriggerOutput: ='TextInputCanvas.TriggerOutput'.Delayed
                Type: ="Text"
                ValidationState: ="None"
                Value: |-
                    =With({ownIsValid: 
                        IfError( 
                            With({rgbaR: Int(txtOwnR.Value), rgbaG: Int(txtOwnG.Value), rgbaB: Int(txtOwnB.Value), tmp_rgbaA: Value(txtOwnA.Value)}, 
                                With({rgbaA: If(tmp_rgbaA > 0 && tmp_rgbaA < 1, tmp_rgbaA, 
                                    If(tmp_rgbaA / 100 <=1, tmp_rgbaA/100, -1))
                                }, 
                                    If(rgbaR >=0 && rgbaR <=255 && rgbaG >=0 && rgbaG <=255 && rgbaB >=0 && rgbaB <=255 && rgbaA > 0 && rgbaA <=1 && (rgbaR + rgbaG + rgbaB) > 0, 
                                        true, 
                                        false
                                    )
                                )
                            )    
                        ,
                        false)
                        }, 
                        If(ownIsValid,"CUSTOM COLOR VALID","")
                    )
                Visible: =true
                Width: =211
                X: =8
                Y: =txtOwnR.Y + txtOwnR.Height + 5 
                ZIndex: =69

            txtColorPaleteLabel As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =false
                BorderColor: =RGBA(214, 221, 224, 1)
                BorderRadius: =4
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =clr_BLUEBERRY
                FontItalic: =false
                FontStrikethrough: =false
                FontUnderline: =false
                Height: =40
                PaddingLeft: =10
                Size: =11
                TabIndex: =0
                Text: ="DEMO COLOR PALETTE"
                Tooltip: =""
                VerticalAlign: =VerticalAlign.Middle
                Visible: =true
                Weight: ='TextCanvas.Weight'.Bold
                Width: =galSelectColor.Width
                Wrap: =true
                X: =galSelectColor.X 
                Y: =Rectangle1_1.Y + Rectangle1_1.Height + 5 
                ZIndex: =70

            txtJSONLabel As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =false
                BorderColor: =RGBA(214, 221, 224, 1)
                BorderRadius: =4
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =clr_BLUEBERRY
                FontItalic: =false
                FontStrikethrough: =false
                FontUnderline: =false
                Height: =40
                PaddingLeft: =10
                Size: =11
                TabIndex: =0
                Text: |-
                    ="INFORMATIONAL: JSON STRUCTURE FOR MENU ITEM, BASED ON VALUES FROM 'CREATE MENU ITEM'"
                Tooltip: =""
                VerticalAlign: =VerticalAlign.Middle
                Visible: =true
                Weight: ='TextCanvas.Weight'.Bold
                Width: =300
                Wrap: =true
                X: =txtColorPaleteLabel.X + txtColorPaleteLabel.Width + 10 
                Y: =Rectangle1_1.Y + Rectangle1_1.Height + 5 
                ZIndex: =71

            txtCurrentSelectedMenu As Text:
                Align: ='TextCanvas.Align'.Center
                AutoHeight: =false
                BorderColor: =RGBA(214, 221, 224, 1)
                BorderRadius: =4
                BorderStyle: =BorderStyle.Solid
                BorderThickness: =1
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =clr_BLUEBERRY
                FontItalic: =false
                FontStrikethrough: =false
                FontUnderline: =false
                Height: =40
                PaddingLeft: =10
                Size: =11
                TabIndex: =0
                Text: |-
                    =$"List of menu items for menuKey: '{pbMenu_Build.MenuKey}'. To delete items, select below, then use the delete menu item in the far left vertical pbMenu"
                Tooltip: =""
                VerticalAlign: =VerticalAlign.Middle
                Visible: =true
                Weight: ='TextCanvas.Weight'.Bold
                Width: =Parent.Width - Self.X - 10 
                Wrap: =true
                X: =txtJSONLabel.X + txtJSONLabel.Width + 10 
                Y: =txtJSONLabel.Y 
                ZIndex: =72

            toggIsBusyEnabled As Toggle:
                AccessibleLabel: =""
                BasePaletteColor: =RGBA(246, 142, 104, 1)
                Checked: =enableIsBusyResponse
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =RGBA(160, 64, 8, 1)
                FontItalic: =false
                FontSize: =12
                FontStrikethrough: =false
                FontUnderline: =false
                FontWeight: =FontWeight.Bold
                Height: =26  
                Label: ="Respond to IsBusy"
                LabelPosition: ="After"
                OnCheck: |-
                    =UpdateContext({enableIsBusyResponse: true}); 
                OnSelect: =false
                OnUncheck: |-
                    =UpdateContext({enableIsBusyResponse: false}); 
                TabIndex: =0
                ToggleSize: =14
                Tooltip: =""
                Visible: =true
                Width: =220
                X: =toggIgnoreUnhandled.X + toggIgnoreUnhandled.Width
                Y: =68
                ZIndex: =73

        Container2 As groupContainer.manualLayoutContainer:
            BorderColor: =pbMenu_Build.BorderColor
            BorderThickness: =2
            DropShadow: =DropShadow.Light
            Fill: =pbMenu_Build.Fill
            Height: =Parent.Height - Self.Y - 10 
            RadiusBottomLeft: =4
            RadiusBottomRight: =4
            RadiusTopLeft: =4
            RadiusTopRight: =4
            Visible: =showAboutExMenu=true
            Width: =Parent.Width - Self.X - 10 
            X: =If(pbMenu_Build.ToolbarOrientation=pbMenu_Build.LayoutChoices.Horizontal,pbMenu_Build.X,pbMenu_Build.X + pbMenu_Build.Width + 10)
            Y: =If(pbMenu_Build.ToolbarOrientation=pbMenu_Build.LayoutChoices.Horizontal,pbMenu_Build.Y + pbMenu_Build.Height + 10,pbMenu_Build.Y)
            ZIndex: =30

            btnCloseAboutExMenu As Button:
                DisplayMode: =DisplayMode.Edit
                Height: =32
                OnSelect: |
                    =UpdateContext({showAboutExMenu:false});
                    pbMenu_MenuBuilder.ItemState_UpdateAll(true)
                Text: ="OK"
                Width: =96
                X: =Parent.Width / 2 - Self.Width / 2 
                Y: =action_LaunchGitHubPage.Y + action_LaunchGitHubPage.Height + 20
                ZIndex: =1

            action_LaunchGitHubPage As confirmAction:
                ButtonBorderColor: =RGBA(15, 108, 189, 1)
                ButtonColorFill: =RGBA(15, 108, 189, 1)
                ButtonStyle: ="Primary"
                ButtonText: ="View Example Menu Code (Github)"
                ButtonTextSize: =18
                ComponentBorderWidth: =3
                DefaultIcon: ="Globe"
                FontColorFill: =RGBA(255, 255, 255, 1)
                FontColorOutline: =RGBA(15, 108, 189, 1)
                FontWeight: ="Bold"
                Height: =80
                OnActionConfirmed: |-
                    =Launch("https://github.com/lopperman/pbMenu/blob/main/files/exampleMenu_code.pdf");
                    Select(btnCloseAboutExMenu)
                Width: =300
                X: =Parent.Width / 2 - Self.Width / 2 
                Y: =20
                ZIndex: =3

            ico_bonusArrow As Icon:
                DisplayMode: =DisplayMode.Edit
                Height: =action_LaunchGitHubPage.Height
                Icon: ="ArrowRight"
                IconColor: =clr_BLUEBERRY
                IconStyle: ='Icon.IconStyle'.Filled
                Width: =64
                X: =action_LaunchGitHubPage.X - Self.Width -30
                Y: =action_LaunchGitHubPage.Y 
                ZIndex: =4

            txtBonusControl As Text:
                Align: ='TextCanvas.Align'.End
                DisplayMode: =DisplayMode.Edit
                FontColor: =clr_BLUEBERRY
                Height: =ico_bonusArrow.Height
                Size: =16
                Text: ="'Bonus' Custom Component (confirmAction)"
                VerticalAlign: =VerticalAlign.Middle
                Weight: ='TextCanvas.Weight'.Bold
                Width: =250
                X: =ico_bonusArrow.X - Self.Width - 20 
                Y: =ico_bonusArrow.Y 
                ZIndex: =5

            Image1 As image:
                BorderColor: =RGBA(0, 0, 0, 0)
                BorderStyle: =BorderStyle.None
                BorderThickness: =2
                DisabledBorderColor: =RGBA(0, 0, 0, 0)
                DisabledFill: =RGBA(0, 0, 0, 0)
                FocusedBorderThickness: =4
                Height: =168
                HoverBorderColor: =RGBA(0, 0, 0, 0)
                HoverFill: =RGBA(0, 0, 0, 0)
                Image: =exampleMenu
                PressedBorderColor: =RGBA(0, 0, 0, 0)
                PressedFill: =RGBA(0, 0, 0, 0)
                Width: =1086
                X: =Parent.Width / 2 - Self.Width / 2 
                Y: =btnCloseAboutExMenu.Y + btnCloseAboutExMenu.Height + 20
                ZIndex: =6

            txtBonusControl_1 As Text:
                Align: ='TextCanvas.Align'.Start
                AutoHeight: =false
                BorderStyle: =""
                ContentLanguage: =""
                DisplayMode: =DisplayMode.Edit
                Font: =""
                FontColor: =clr_BLUEBERRY
                FontItalic: =false
                FontStrikethrough: =false
                FontUnderline: =false
                Height: =ico_bonusArrow.Height
                Size: =12
                TabIndex: =0
                Text: =$"The menu with the light yellow background ('pbMenu_Build') can be controlled & configured with the demo properties on this screen (e.g. 'Menu Orientation', 'Manage Item States'{const_CrLf}* Click 'CREATE EXAMPLE MENU' to add menu items with an assortment of behaviors"
                Tooltip: =""
                VerticalAlign: =VerticalAlign.Top
                Visible: =true
                Weight: ='TextCanvas.Weight'.Bold
                Width: =Image1.Width
                Wrap: =true
                X: =Image1.X 
                Y: =Image1.Y + Image1.Height + 10 
                ZIndex: =7

        txtBuildScreenInfo As Text:
            Align: ="Start"
            AutoHeight: =true
            BorderColor: =RGBA(106, 122, 127, 1)
            BorderRadius: =4
            BorderStyle: =BorderStyle.Solid
            BorderThickness: =1
            ContentLanguage: =""
            DisplayMode: =DisplayMode.Edit
            Fill: =RGBA(232, 233, 235, 1)
            Font: =""
            FontColor: =clr_BLUEBERRY
            FontItalic: =false
            FontStrikethrough: =false
            FontUnderline: =false
            Height: =42
            PaddingLeft: =10
            Size: =14
            TabIndex: =0
            Text: ="TO GET STARTED, click the 'CREATE EXAMPLE MENU' menu item (above), or fill out 'CREATE MENU ITEM' section below, and click the Save button on the far left vertical menu.  See 'ABOUT EXAMPLE MENU' for more info"
            Tooltip: =""
            VerticalAlign: =VerticalAlign.Middle
            Visible: =true
            Weight: ='TextCanvas.Weight'.Bold
            Width: =Parent.Width - Self.X - 10 
            Wrap: =true
            X: =txtBuildingThisMenu_1.X + txtBuildingThisMenu_1.Width + 10 
            Y: =If(Coalesce(ddMenuOrientation.Selected.Value,pbMenu_BuildHelper.LayoutChoices.Horizontal)="Vertical",10, pbMenu_Build.X + pbMenu_Build.Height + 10)
            ZIndex: =31

        iconMenuArrow_1 As Icon:
            ContentLanguage: =""
            DisplayMode: =DisplayMode.Edit
            Height: =42
            Icon: =If(Coalesce(ddMenuOrientation.Selected.Value,pbMenu_BuildHelper.LayoutChoices.Horizontal)="Vertical","ArrowLeft","ArrowUp")
            IconColor: =RGBA(255, 0, 0, 1)
            IconStyle: ='Icon.IconStyle'.Filled
            Rotation: =0
            TabIndex: =0
            Tooltip: =""
            Visible: =true
            Width: =40
            X: =If(Coalesce(ddMenuOrientation.Selected.Value,pbMenu_BuildHelper.LayoutChoices.Horizontal)="Vertical", pbMenu_Build.X + pbMenu_Build.Width + 10,10)
            Y: =If(Coalesce(ddMenuOrientation.Selected.Value,pbMenu_BuildHelper.LayoutChoices.Horizontal)="Vertical",10, pbMenu_Build.X + pbMenu_Build.Height + 10)
            ZIndex: =32

        txtBuildingThisMenu_1 As Text:
            Align: ="Start"
            AutoHeight: =false
            BorderColor: =RGBA(214, 221, 224, 1)
            BorderRadius: =4
            BorderStyle: =BorderStyle.Solid
            BorderThickness: =1
            ContentLanguage: =""
            DisplayMode: =DisplayMode.Edit
            Font: =""
            FontColor: =clr_BLUEBERRY
            FontItalic: =false
            FontStrikethrough: =false
            FontUnderline: =false
            Height: =42
            PaddingLeft: =10
            Size: =14
            TabIndex: =0
            Text: ="CURRENTLY BUILDING THIS MENU"
            Tooltip: =""
            VerticalAlign: =VerticalAlign.Middle
            Visible: =true
            Weight: ='TextCanvas.Weight'.Bold
            Width: =180
            Wrap: =true
            X: =iconMenuArrow_1.X + iconMenuArrow_1.Width + 5 
            Y: =If(Coalesce(ddMenuOrientation.Selected.Value,pbMenu_BuildHelper.LayoutChoices.Horizontal)="Vertical",10, pbMenu_Build.X + pbMenu_Build.Height + 10)
            ZIndex: =33

    pbMenu_BuildHelper As pbMenu:
        BusyBehavior: =Self.BusyBehaviorChoices.Disabled
        Collapse: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            If(Self.EnableUserCollapse=false, 
                                false, 
                                pbMenu_BuildHelper.DefaultCollapsedState
                            )
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=false, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu_BuildHelper.ControlGUID), menuKey: pbMenu_BuildHelper.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: true,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:true})
                            )
                        )
                    )
            
                )    
            )
        CollapsedMode: |-
            =//If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal || Self.EnableCollapsedState<>true, false,     
            If(Self.ToolbarOrientation=Self.LayoutChoices.Horizontal, false,     
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    If(IsBlank(collapseRec), 
                        pbMenu_BuildHelper.DefaultCollapsedState
                        , 
                        collapseRec.boolValue
                    )       
                )
            )
        ConfirmAction: |+
            =With({Perf: {id: GUID(), start: Now(), action: $"CONFIRM ACTION: {p_menuKey}.{p_itemKey} ({p_itemDisplay})"}}, 
                RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm");
                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: p_menuKey,itemKey: p_itemKey, action: "confirm", boolValue: true,  desc: p_itemDisplay});
                If(pbMenu.PerformanceLogging=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
            
        ConfirmMode: =CountIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")>0
        CreateInfoItem: |
            =With({newMenuItem: 
                //get menu item structure
                {
                    menuKey: Upper(TrimEnds(p_menuKey)), 
                    ItemKey: Upper($"_info_{GUID()}"), 
                    ItemDisplayName: TrimEnds(p_itemDisplay), 
                    ItemIconName: "Info", 
                    ItemAppearance: TrimEnds(p_itemAppearance), 
                    ItemIconStyle: pbMenu.ItemIconStyleChoices.Filled, 
                    ItemTooltip: TrimEnds(p_itemTooltip), 
                    ItemDisabled: false, 
                    disableOnSelect: false, 
                    confirmItemAction: false
                }}
                , 
                If(p_addToCollection=true, 
                    RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                    Collect(col_pbMenu,newMenuItem)
                );
                newMenuItem 
            )
        CreateMenuItem: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE MENU ITEM: {p_menuKey}.{p_ItemKey} ({p_ItemDisplayName})"}}, 
                With({isSpacer: (Len(TrimEnds(p_ItemKey))=0)=true},     
                    With({newMenuItem: 
                        If(isSpacer, 
                            //get spacer structure (without adding -- can be added to collection below if appropriate)
                            Self.CreateSpacer(p_menuKey,false), 
                            //get menu item structure
                            {menuKey: Upper(TrimEnds(p_menuKey)), ItemKey: Upper(TrimEnds(Coalesce(p_ItemKey,$"_spacer_{GUID()}"))), ItemDisplayName: If(isSpacer,"",TrimEnds(p_ItemDisplayName)), ItemIconName: If(isSpacer," ", TrimEnds(p_ItemIconName)), ItemAppearance: TrimEnds(p_ItemAppearance), ItemIconStyle: TrimEnds(p_ItemIconStyle), ItemTooltip: TrimEnds(p_ItemTooltip), ItemDisabled: isSpacer, disableOnSelect: p_disableOnSelect, confirmItemAction: p_confirmItemAction}
                        )}, 
                        If(p_addToCollection=true, 
                            RemoveIf(col_pbMenu,menuKey=newMenuItem.menuKey && ItemKey=newMenuItem.ItemKey);
                            Collect(col_pbMenu,newMenuItem)
                        );
                        If(pbMenu.PerformanceLogging=true, 
                            With({endTS: Now()}, 
                                Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                            )
                        );
                        newMenuItem 
                    )
                )
            )
        CreateSpacer: |
            =With({Perf: {id: GUID(), start: Now(), action: $"CREATE SPACER: {p_menuKey} (Add to collection: {p_addToCollection})"}}, 
                With({newSpacer: 
                    If(Len(TrimEnds(p_menuKey))=0, 
                        Blank(), 
                        {
                            menuKey: Upper(TrimEnds(p_menuKey)), 
                            ItemKey: $"_spacer_{GUID()}", 
                            ItemDisplayName: " ", 
                            ItemIconName: "", 
                            ItemAppearance: Self.ItemAppearanceChoices.Transparent,  
                            ItemIconStyle: Self.ItemIconStyleChoices.Outline, 
                            ItemTooltip: "", 
                            ItemDisabled: true, 
                            disableOnSelect: false, 
                            confirmItemAction: false    
                        }
                    )}, 
                    If(p_addToCollection=true && Not(IsBlank(newSpacer)), 
                        Collect(col_pbMenu,newSpacer)
                    );
                    If(pbMenu.PerformanceLogging=true, 
                        With({endTS: Now()}, 
                            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                        )
                    );
                    newSpacer
                )
            )
        DoMenu: |-
            =With({spinning: spin.waiting=true, spinningMsg: spin.msg}, 
                If(Not(spinning), Set(spin, {waiting: true, msg: "Please wait ..."}));
                With({mi: pbMenu.MenuItem(p_menuKey,p_itemKey)}, 
                    If(mi.confirmItemAction=true, 
                        If(Self.ConfirmMode() <> true, 
                            //Add 'confirm' action and waits for user to confirm or cancel
                            //cancel clears confirm action
                            //confirm calls DoMenu again, which can then move forward
                            Self.ConfirmAction(p_menuKey,p_itemKey,mi.ItemDisplayName)
                            , 
                            //clear the 'confirm' action, which is now confirmed, and 
                            //process menuItem as normal
                            RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="confirm")
                        )
                    );
                    With({doMenuHandled: 
                        If(Self.ConfirmMode() <> true, 
                            If(pbMenu.ManageItemStates = true, 
                                pbMenu.ItemState_UpdateAll(true);
                                If(mi.disableOnSelect=true, 
                                    pbMenu.ItemState(mi.ItemKey,false)
                                )
                            );
                            //Raise 'OnBeforeAction'.  If handled in event on screen ('true' returned), no further action is taken.
                            //If not handled in the 'OnBeforeAction', will attempt to handle below and show error if was not handled.
                            If(Self.OnBeforeAction(p_itemKey) = true, 
                                true
                                , 
                                With({handledHere: 
                                    Switch(Upper(p_itemKey), 
                                        "LAUNCHGITHUB", Launch("https://github.com/lopperman"); true, 
                                        "LAUNCHREDDIT", Launch("https://www.reddit.com/user/ITFuture"); true, 
                                        "GOOGLE", Launch("https://www.google.com"); true, 
                                        "MINAVPERF", Navigate(PerformanceLog,ScreenTransition.Fade); true, 
            
                                        //not handled
                                        Notify("NO ACTION WAS TAKEN FOR MENU ITEM: " & p_menuKey & "." & p_itemKey & " (" & mi.ItemDisplayName & ")",NotificationType.Error,5000);
                                        false
                                    )}, 
                                    handledHere
                                )
                            );
                        )
                        }, 
                        If(Not(spinning), Set(spin,{waiting: false,msg:"Please wait ..."}));
                        doMenuHandled
                    )
            
                );
            )
        EnableUserCollapse: =false
        Expand: |-
            =If(Lower(Self.ToolbarOrientation)=Lower(Self.LayoutChoices.Vertical), 
                //determine if current state is expanded
                With({collapseRec: LookUp(col_pbMenuUtil,menuGuid=GUID(Self.ControlGUID) && action="collapse")}, 
                    With({isCollapsed: 
                        If(IsBlank(collapseRec), 
                            pbMenu_BuildHelper.DefaultCollapsedState
                            , 
                            collapseRec.boolValue
                        )}, 
                        If(isCollapsed=true, 
                            If(IsBlank(collapseRec), 
                                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu_BuildHelper.ControlGUID), menuKey: pbMenu_BuildHelper.MenuKey,itemKey: "_COLLAPSE", action: "collapse", boolValue: false,  desc: ""})
                                , 
                                Patch(col_pbMenuUtil, collapseRec, {boolValue:false})
                            )
                        )
                    )
                )    
            )
        Fill: =RGBA(232, 233, 235, 1)
        Height: =Parent.Height - Self.Y - 10 
        Information: |-
            =[
                {
                    name: "About", 
                    type: "General pbMenu Help",
                    desc: "** NOTE: '[pbMenu]' is referenced in this documentation in relation to getting/setting/calling actions for a pbMenu component. Please remember that 'pbMenu' can never be referenced directly from a screen, and should be replaced with the name of the pbMenu component on your screen.  For example, if you added a pbMenu component to your screen, and named it 'mainMenu1', that all interactions for that menu would use 'mainMenu1', and not 'pbMenu'"        
                },
                {
                    name: "ToolbarOrientation", 
                    valText: Self.ToolbarOrientation, 
                    dataType: "Text", 
                    externalUse: "[pbMenu].LayoutChoices.Horizontal (default), or [pbMenu].LayoutChoices.Vertical", 
                    type: "Input Property",
                    desc: "Use to get or set the orientation of [pbMenu]"
                },
                {
                    name: "MinimumHeight()", 
                    valNumber: Self.MinimumHeight(), 
                    dataType: "Number", 
                    externalUse: "When in 'Horizontal' layout mode, set the pbMenu component (added to your screen) 'Height' property to be 'Self.MinimumHeight()'", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Height, when in Horizontal layout mode.  Note: Property 'OverrideMinHeight can be used to fine tune desired menu height."
                },
                {
                    name: "MinimumWidth()", 
                    valNumber: Self.MinimumWidth(), 
                    dataType: "Number", 
                    externalUse: "When in 'Vertical' layout mode, set the pbMenu component (added to your screen) 'Width' property to be 'Self.MinimumWidth()'.  This will enable the pbMenu control to automatically resize when user collapses or expands the menu.", 
                    type: "Output Function", 
                    desc: "Provides recommended pbMenu Width, when in Vertical layout mode,  Note: if you need to adjust the expanded width, use the 'OverrideExpandedWidth' property to set the desired expanded width value"
                },
                {
                    name: "CurrentMenuItems", 
                    valTable: Self.CurrentMenuItems, 
                    dataType: "Table", 
                    externalUse: "Reference Only", 
                    type: "Output Property",
                    desc: "Current Menu Items.   Retrieved by filtering items from 'MenuData' datasource, where menuName=[pbMenu].MenuKey"
                },
                {
                    name: "CancelMenuColorPalette", 
                    valColor: Self.CancelMenuColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Cancel' button; Default is RGBA(0,0,0,0)", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Cancel' button for required user confirmation"
                },
                {
                    name: "CollapseMode()", 
                    valBoolean: Self.CollapsedMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function",
                    desc: "Returns true when 'ToolbarOrientation' is Vertical and menu is collapsed"
                },
                {
                    name: "DefaultCollapsedState", 
                    valBoolean: Self.DefaultCollapsedState, 
                    dataType: "Boolean", 
                    externalUse: "Use to set default collapsed state (true=collapsed, false=expanded)", 
                    type: "Input Property", 
                    desc: "When true, default state of menu will be collapsed, when menu is configured for vertical layout"
                }, 
                {
                    name: "EnableUserCollapse", 
                    valBoolean: Self.EnableUserCollapse, 
                    dataType: "Boolean", 
                    externalUse: "Set to 'false' to prevent vertical menu from ever displaying in collapsed/icon-only mode", 
                    type: "Input Property", 
                    desc: "Defaults to true; controls whether vertical menu can be collapsed"
                }, 
                {
                    name: "ConfirmationColorPalette", 
                    valColor: Self.ConfirmationColorPalette, 
                    dataType: "Color", 
                    externalUse: "Use to set color palette of Confirmation 'Confirm' button", 
                    type: "Input Property",
                    desc: "Color Palette used when displaying 'Confirm' button for required user confirmation"
                }, 
                {
                    name: "ConfirmMode()", 
                    valBoolean: Self.ConfirmMode(), 
                    dataType: "Boolean", 
                    externalUse: "Reference Only, must be called as function", 
                    type: "Output Function", 
                    desc: "When user has selected a menu item which requires confirmation, [pbMenu].'ConfirmMode()' will return true until user has selected 'Confirm' or 'Cancel'"
                }, 
                {   
                    name: "ControlGUID", 
                    valText: Self.ControlGUID, 
                    dataType: "Text", 
                    externalUse: "Reference Only.  VALUE WILL CHANGE BETWEEN SESSIONS!", 
                    type: "Output Property", 
                    desc: "Unique value which can be used at runtime only, and may update each time a screen becomes visible.  The purpose of this property is to manage specific state information"
                }, 
                {
                    name: "ItemAppearanceChoices", 
                    valRecord: Self.ItemAppearanceChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemAppearance' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property wich can be used when setting value for 'ItemAppearance', when creating a new menu item using [pbMenu].'Create Menu Item'()"
                }, 
                {
                    name: "ItemIconStyleChoices", 
                    valRecord: Self.ItemIconStyleChoices, 
                    dataType: "Record", 
                    externalUse: "Use to set 'ItemIconStyle' property when creating new menu items", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value for 'ItemIconStyle', when creating a new menu item using [pbMenu].'Create Menu Item'"
                }, 
                {
                    name: "LayoutChoices", 
                    valRecord: Self.LayoutChoices, 
                    dataType: "Record", 
                    externalUse: "Helper used to set valid [pbMenu].ToolbarOrientation", 
                    type: "Output Property", 
                    desc: "Helper property which can be used when setting value of [pbMenu].ToolbarOrientation"
                }, 
                {
                    name: "ConfirmAction", 
                    dataType: "n/a", 
                    externalUse: "Optionally can be used to trigger a menu item selection confirmation (see desc)", 
                    type: "Component Action", 
                    desc: "Trigger action which requires user to confirm or cancel selected menu item.  Used internally by pbMenu when a menu item is selected that was created with 'confirmItemAction' = true. While not intended to be called externally, this action can be triggered outside the pbMenu component as long as the parameter arguments (p_menuKey, p_itemKey, p_itemDisplay) match a menu item which currently is being displayed in [pbMenu]"
                }, 
                {
                    name: "CreateMenuItem", 
                    type: "Component Action", 
                    dataType: "Record", 
                    externalUse: "Returns Menu Item Record data which is also automatically added to collection: col_pbMenu if the 'p_addToCollection' argument is true", 
                    desc: "Returns a menu item record based on provided parameter values.  By default, new menu item is not added to a data source and therefore will not be available for use.  When called with p_addToCollection=true, the new menu item will be added to col_pbMenu (default data source for [pbMenu]), and becomes available for use by any pbMenu component.", 
                    example: $"To get the correct structure (record) of a menu item you wish to add, which will be stored in an external datasource -- like SharePoint or DataVerse -- the following would return that record and NOT add it to the default MenuData datasource ('col_pbMenu'):  [pbMenu].CreateMenuItem({Char(34)}Main{Char(34)},{Char(34)}miNavBuild{Char(34)},{Char(34)}MENU BUILDER{Char(34)},{Char(34)}ArrowRight{Char(34)},[pbMenu].ItemAppearanceChoices.Primary,[pbMenu].ItemIconStyleChoices.Filled,{Char(34)}Build a Menu{Char(34)},false,false,false);, setting the last parameter to 'true' would cause the new menu item to also be added to 'col_pbMenu'"
                }, 
                {
                    name: "DoMenu", 
                    externalUse: "Optionally use to trigger a menu item selection (see desc)", 
                    type: "Component Action", 
                    desc: "Called when user selects a menu item which was rendered from [pbMenu].MenuData data source. Can also be called externally. When a menu item that requires user confirmation is selected, 'DoMenu' is not called until user also selects the confirmation button. When 'DoMenu' is called externally, the item key property is NOT required to correlate to a menu item currently available, as long as the pbMenu being called is able to process the 'p_ItemKey' argument in the [pbMenu].OnBeforeAction event on the current screen."
                }, 
                {
                    name: "ManageItemStates", 
                    valBoolean: Self.ManageItemStates, 
                    dataType: "Boolean", 
                    externalUse: "Used to enable a pbMenu to change menu item states automatically (default: true)", 
                    type: "Input Property", 
                    desc: "When set to true (default), any menu item selected which has 'disableOnSelect' property set to true, will become disabled when selected, and will become re-enabled when any other menu item is selected. When 'ManageItemStates' is set to false, the 'disableOnSelect' menu item property is ignored"
                }, 
                {
                    name: "ItemState", 
                    externalUse: "can be used to manually enable/disable menu items (when [pbMenu].ManageItemStates is false)", 
                    type: "Component Action", 
                    desc: "Used internally by pbMenu to enable/disable a menu item.  Can be called externally to enable/disable a menu item at any time.  Note:  When 'ManageItemStates' is set to true, pbMenu will allways re-enable all menu items when any menu item is selected."
                }, 
                {
                    name: "ItemState_UpdateAll", 
                    type: "Component Action", 
                    desc: "Used internally to re-enable all menu items.  Can be called externally to enable or disable all menu items.  Please remember that when 'ManageItemStates' is set to true, all menu items are enabled any time a menu item is selected.", 
                    canCall: true 
                }, 
                {
                    name: "MenuColorPalette", 
                    valColor: Self.MenuColorPalette, 
                    dataType: "Color", 
                    type: "Input Property", 
                    desc: "Color pallete used for menu items.  Defaults to 'PowerAppsTheme.Colors.Primary'", 
                    canSet: true 
                }, 
                {
                    name: "MenuData_All", 
                    valTable: Self.MenuData_All, 
                    dataType: "Table", 
                    type: "Output Property", 
                    desc: "Unfiltered records from col_pbMenu. This Table/collection contains configuration records for all menu items in all defined menus"
                }, 
                {
                    name: "IsBusy", 
                    valBoolean: Self.IsBusy, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
                {
                    name: "IsBusyEnabled", 
                    valBoolean: Self.IsBusyEnabled, 
                    dataType: "Boolean", 
                    type: "Input Property", 
                    desc: "A boolean value indicated the app is currency busy. Recommend setting to global boolean variable that is always turned on when an action (e.g. getting or editing data, complex operations, etc) begins, and turned off when the action completes. Indicating the app is busy will either cause pbMenu to display a spinner and message, or will disabled display menu, depending on pbMenu.BusyBehavior setting"
                }, 
            
                {
                    name: "BusyMessage", 
                    valText: Self.BusyMessage, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "The message that is displayed in the pbMenu container, when pbMenu.IsBusy=true, and pbMenu.BusyBehavior='Spinner'."
                }, 
                {
                    name: "BusyBehavior", 
                    valText: Self.BusyBehavior, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Text value to indicate pbMenu behavior when pbMenu.IsBusy=true.  A helper property (pbMenu.BusyBehaviorChoices) can be use to set this property.  Valid value are either 'BusyBehaviorChoices.Spinning' ('Spinning'), or 'BusyBehaviorChoices.Disabled' ('Disabled').  When this property is missing or contains an invalid value, the default value ('Spinning') will be used."
                }, 
                {
                    name: "BusyBehaviorChoices", 
                    valRecord: Self.BusyBehaviorChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which contains valid choices for the pbMenu.BusyBehavior input property"
                }, 
                {
                    name: "ToolbarPadding", 
                    valText: Self.ToolbarPadding, 
                    dataType: "Text", 
                    type: "Input Property", 
                    desc: "Toolbar padding is managed automatically ('Medium' for Horizontal Layout, 'Small' for Vertical Layout.)  If adjustment is necessary, can be overridden ('Small', 'Medium', 'Large').  A helper property exists to select choices (ToolbarPaddingChoices).  For example, if the name of your on-screen pbMenu component was 'myMenu' and you wanted to force 'Large' padding, you would set the 'ToolbarPadding' property to: myMenu.ToolbarPaddingChoices.Large"
                }, 
                {
                    name: "ToolbarPaddingChoices", 
                    valRecord: Self.ToolbarPaddingChoices, 
                    dataType: "Record", 
                    type: "Output Property", 
                    desc: "Helper property which provides valid 'ToolbarPadding' choices"
                }
            
            ]
        ItemState: |
            =With({Perf: {id: GUID(), start: Now(), action: $"ITEM STATE CHANGE: {pbMenu.MenuKey}.{p_itemKey} (enabled: {p_enabled})"}}, 
                If(Not(StartsWith(Lower(p_itemKey),"_spacer_")) || Not(p_enabled), 
                    UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey) && Upper(ItemKey)=Upper(p_itemKey),{ItemDisabled:Not(p_enabled)})        
                );
            
            //    RemoveIf(col_pbMenuUtil,menuGuid=GUID(pbMenu.ControlGUID) && action="disable" && Upper(itemKey)=Upper(p_itemKey));
            //    With({isSpacer:StartsWith(Lower(p_itemKey),"_spacer_")}, 
            //        With({tmpMenuItem: pbMenu.MenuItem(pbMenu.MenuKey,p_itemKey), shouldDisable: If(isSpacer, true, Not(p_enabled))}, 
            //            If(p_enabled=false, 
            //                Collect(col_pbMenuUtil,{menuGuid: GUID(pbMenu.ControlGUID), menuKey: pbMenu.MenuKey,itemKey: p_itemKey, action: "disable", boolValue: true,  desc: ""});
            //            );
            //            If(tmpMenuItem.ItemDisabled<>shouldDisable, 
            //                Patch(col_pbMenu,tmpMenuItem,{ItemDisabled:shouldDisable})
            //            )
            //        )
            //    );
                If(pbMenu.PerformanceLogging=true && p_enablePerfLog=true, 
                    With({endTS: Now()}, 
                        Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
                    )
                )
            )
        ItemState_UpdateAll: |
            =With({Perf: {id: GUID(), start: Now(), action: $"UPDATE ITEM STATES (ALL): {pbMenu.MenuKey} (Enabled: {p_Enabled})"}}, 
                UpdateIf(col_pbMenu,Upper(menuKey)=Upper(Self.MenuKey),{ItemDisabled:Not(p_Enabled)});
            
            //    ForAll(pbMenu.MenuItems As mItem, 
            //        pbMenu.ItemState(mItem.ItemKey,p_Enabled,false)
            //    );
            
            //    pbMenu.Reset();
            //    If(pbMenu.PerformanceLogging=true, 
            //        With({endTS: Now()}, 
            //            Collect(col_pbMenuPerf,{id: Perf.id, elapsed: DateDiff(Perf.start,endTS,TimeUnit.Milliseconds), start: Perf.start, end: Now(),  action: Perf.action})
            //        )
            //    )
            )
        ManageItemStates: =false
        MenuColorPalette: =If(mbMode="View", PowerAppsTheme.Colors.Darker30,Color.Green)
        MenuItem: =LookUp(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_itemKey))
        MenuKey: =helperMenu
        MinimumHeight: =If(Upper(Self.ToolbarOrientation)=Upper(pbMenu.LayoutChoices.Horizontal),If(Self.OverrideMinHeight>0,Self.OverrideMinHeight, 50),140) 
        MinimumWidth: |
            =If(pbMenu.ToolbarOrientation=pbMenu.LayoutChoices.Horizontal,200,
                If(pbMenu.CollapsedMode()=true,50,
                    If(pbMenu.OverrideExpandedWidth<=0,
                        120, 
                        pbMenu.OverrideExpandedWidth
                    )
                )
            )
        OnBeforeAction: |-
            =Switch(Upper(p_itemKey), 
                "MBHJSON", 
                    UpdateContext({helperView: "menuItemsJSON"});
                    pbMenu_BuildHelper.ItemState_UpdateAll(false);
                    pbMenu_BuildHelper.ItemState("mbhMenuProps",true);
            
                    true, 
                "MBHMENUPROPS", 
                    UpdateContext({helperView: "menuProps"});
            
                    pbMenu_BuildHelper.ItemState_UpdateAll(true);
                    pbMenu_BuildHelper.ItemState("mbhMenuProps",false);
            
                    
                    true, 
                "MBHINPUTPROPS", 
                    UpdateContext({infoSearch: "Input Property"}); Reset(srch_pbMenuInfo);
                    true, 
                "MBHOUTPUTPROPS", 
                    UpdateContext({infoSearch: "Output Property"}); Reset(srch_pbMenuInfo);
                    true, 
                "MBHOUTPUTFUNCTIONS", 
                    UpdateContext({infoSearch: "Output Function"}); Reset(srch_pbMenuInfo);
                    true, 
                "MBHMENUITEMS", 
                    UpdateContext({infoSearch: "CurrentMenuItems"}); Reset(srch_pbMenuInfo);
                    true, 
                "MBHACTIONS", 
                    UpdateContext({infoSearch: "Component Action"}); Reset(srch_pbMenuInfo);
                    true, 
            
                    
                "MBBSAVE", 
                    With({newMenuItem: 
                        pbMenu_Build.CreateMenuItem(
                            $"{Coalesce(txtMenuName.Value,"menu name")}", 
                            txtMenuItemKey.Value, 
                            $"{Coalesce(txtMenuItemDisplay.Value,"[display name]")}", 
                            $"{Coalesce(ddIconName.Selected.Value,"GridDots")}", 
                            $"{Coalesce(ddItemAppearance.Selected.Value, "Primary")}", 
                            $"{ddIconStyle.Selected.Value}",
                            $"{txtMenuItemTooltip.Value}", 
                            toggDisableItemOnSelect.Checked, 
                            toggRequireConfirmation.Checked, 
                            true
                        )
                        }, 
                        If(CountIf(col_BuildMenu,Upper(menuKey)=Upper(newMenuItem.menuKey))=0, 
                            Collect(col_BuildMenu,{menuKey: newMenuItem.menuKey})
                        );
                    );
                    true, 
                "MBBDELETE", 
                    If(CountIf(tblTempMenuItems.SelectedItems,true)=0, 
                        Notify("To Delete, Please select 1 or more saved menu items from table",NotificationType.Warning,3000), 
                        With({deleteKeys: ForAll(tblTempMenuItems.SelectedItems As del, {key: del.ItemKey})}, 
                            ForAll(deleteKeys As dk, 
                                With({tmpMenuKey: ddMenuKey.Selected.Value}, 
                                    RemoveIf(col_pbMenu,Upper(menuKey)=Upper(ddMenuKey.Selected.Value) && Upper(ItemKey)=Upper(dk.key));
                                    If(CountIf(col_pbMenu,Upper(menuKey)=Upper(tmpMenuKey))=0, 
                                        RemoveIf(col_BuildMenu,Upper(menuKey)=Upper(tmpMenuKey));
                                    )
                                )
                            )
                        )
                    );
                    true, 
                "REBUILDDEMOMENUS", dData.BuildDemoMenus(); true, 
                Upper("mbbCreateSpacer"), 
                    If(Len(TrimEnds(txtMenuName.Value))=0, 
                        Notify("Menu Key is required to create spacer.  Please enter menu name in the Menu Name ('Menu Key') Textbox",NotificationType.Error,2000)
                        , 
                        pbMenu_Build.CreateSpacer(txtMenuName.Value,true);
                        Notify($"A new spacer was added for the {txtMenuName.Value} menu" ,NotificationType.Success,3000)
                    );
                    true, 
                
                false
            )
        OnRemoveMenuItem: =
        OverrideExpandedWidth: =140
        PerformanceLogging: =pbMenu_LogPerformance
        RemoveMenuItem: |-
            =RemoveIf(col_pbMenu,Upper(menuKey)=Upper(p_menuKey) && Upper(ItemKey)=Upper(p_menuItemKey));
            Self.OnRemoveMenuItem(p_menuKey,p_menuItemKey)
        Reset: =Reset(pbMenu_BuildHelper)
        ToolbarOrientation: =pbMenu_BuildHelper.LayoutChoices.Vertical
        Width: =If(Self.CollapsedMode(), Self.MinimumWidth(),Self.MinimumWidth() + 30)
        Y: =pbMenu_MenuBuilder.Y + pbMenu_MenuBuilder.Height + 10
        ZIndex: =5

